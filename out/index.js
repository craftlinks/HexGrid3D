async function a(){const E=[512,512],j=1/Math.max(E[0],E[1]),w=await(await navigator.gpu?.requestAdapter())?.requestDevice();if(!w){fail("need a browser that supports WebGPU");return}else console.log("WebGPU is supported");const q=document.querySelector("canvas"),C=q.getContext("webgpu"),H=navigator.gpu.getPreferredCanvasFormat();C.configure({device:w,format:H});const b=await fetch("./shaders/hexgrid3d_vertex.wgsl").then((k)=>k.text()),B=await fetch("./shaders/hexgrid3d_fragment.wgsl").then((k)=>k.text()),D=await fetch("./shaders/hexgrid3d_compute.wgsl").then((k)=>k.text()),S=w.createShaderModule({label:"HexGrid3D vertex shader",code:b}),h=w.createShaderModule({label:"HexGrid3D fragment shader",code:B}),p=w.createShaderModule({label:"HexGrid3D compute module",code:D}),O=8,U=16,v=16,I=E[0]*E[1]*O,W=E[0]*E[1]*U,V=v,X=w.createBuffer({label:"Hex attributes storage buffer for objects",size:I,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),R=w.createBuffer({label:"flip colors storage buffer for objects",size:W,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),Y=w.createBuffer({label:"flop colors storage buffer for objects",size:W,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),Q=w.createBuffer({label:"global attributes uniform",size:V,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),s=0,n=2;{const k=new Float32Array(I/4);for(let y=0;y<E[0]*E[1];++y){const L=y*(O/4);let K=y%E[0],M=Math.floor(y/E[0]);M%2==1||(K+=0.5),k.set([K*Math.sqrt(3)*j,M*3/2*j],L)}w.queue.writeBuffer(X,0,k)}{const k=new Float32Array(W/4);for(let y=0;y<E[0]*E[1];++y){const L=y*(U/4);k.set([0,0,0,1],L);let K=Math.floor(y/E[0]),M=y%E[0];if(T(1)>0.99)k.set([T(0.5),T(1),T(0.75),1],L)}w.queue.writeBuffer(R,0,k)}const{vertexData:P,numVertices:l}=o({hexSize:j,center:{x:-1-j,y:-1+j}}),Z=w.createBuffer({label:"storage buffer vertices",size:P.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});w.queue.writeBuffer(Z,0,P);const $=w.createComputePipeline({label:"compute pipeline",layout:"auto",compute:{module:p,entryPoint:"main"}}),F=w.createRenderPipeline({label:"HexGrid3D pipeline",layout:"auto",vertex:{module:S,entryPoint:"vs"},fragment:{module:h,entryPoint:"fs",targets:[{format:H}]}}),f=w.createBindGroup({label:"flip bind group for objects",layout:F.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:X}},{binding:1,resource:{buffer:R}},{binding:2,resource:{buffer:Q}},{binding:3,resource:{buffer:Z}}]}),m=w.createBindGroup({label:"flop bind group for objects",layout:F.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:X}},{binding:1,resource:{buffer:Y}},{binding:2,resource:{buffer:Q}},{binding:3,resource:{buffer:Z}}]}),u=w.createBindGroup({layout:$.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:Q}},{binding:1,resource:{buffer:R}},{binding:2,resource:{buffer:Y}}]}),d=w.createBindGroup({layout:$.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:Q}},{binding:1,resource:{buffer:Y}},{binding:2,resource:{buffer:R}}]}),A={label:"our basic canvas renderPass",colorAttachments:[{clearValue:[0,0,0,1],loadOp:"clear",storeOp:"store"}]},g=new Float32Array(V/4);function z(k){var y=k;q.width=Math.max(1,w.limits.maxTextureDimension2D),q.height=Math.max(1,w.limits.maxTextureDimension2D),A.colorAttachments[0].view=C.getCurrentTexture().createView();const L=w.createCommandEncoder({label:"our first triangle encoder"}),K=L.beginComputePass();K.setPipeline($),K.setBindGroup(0,k?u:d),K.dispatchWorkgroups(E[0]/4,E[1]/4),K.end();const M=L.beginRenderPass(A);M.setPipeline(F);const c=q.width/q.height,G=1;g.set([G/c,G,E[0],E[1]],0),w.queue.writeBuffer(Q,0,g),M.setBindGroup(0,k?f:m),M.draw(l,E[0]*E[1]),M.end();const x=L.finish();w.queue.submit([x]),y=1-y,setTimeout(()=>{z(y)},50)}z(1)}var o=function({hexSize:E=0.1,center:j={x:0,y:0}}={}){const J=new Float32Array(36),N=new Float32Array(12);for(let w=0;w<6;w++){const q=w*2,C=2*Math.PI*((w+0.5)/6);N[q]=E*Math.cos(C),N[q+1]=E*Math.sin(C)}for(let w=0;w<6;w++){const q=w*6,C=w*2;J[q+0]=j.x,J[q+1]=j.y,J[q+2]=j.x+N[C],J[q+3]=j.y+N[C+1],J[q+4]=j.x+N[(C+2)%12],J[q+5]=j.y+N[(C+3)%12]}return console.log(J),{vertexData:J,numVertices:18}};a();var T=(E,j)=>{if(E===void 0)E=0,j=1;else if(j===void 0)j=E,E=0;return E+Math.random()*(j-E)};
