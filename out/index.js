function f(E,L,C){console.log("Simulation");const q=24,Q=0.004,W=0.008,M=1e4,F=0.6;L.fill(0);for(var R=0;R<C[1];R=R+1)for(var T=0;T<C[0];T=T+1){let K=E[w(T,R)];L.fill(0);let J=H(T,R,E);if(K>0)J[0]=M}for(var R=0;R<C[1];R=R+1)for(var T=0;T<C[0];T=T+1){if(H(T,R,E)[0]==0)continue;g(T,R,1,q)}for(var R=0;R<C[1];R=R+1)for(var T=0;T<C[0];T=T+1){var z=0,V=0,l=H(T,R,L);for(var U=0;U<q/2-1;U+=1)z+=l[U];for(var U=q/2;U<q;U+=1)V+=l[U];if(z==0||V==0){L[w(T,R)]=0;continue}if(Math.floor(z/V)<100)L[w(T,R)]=0;else L[w(T,R)]=1}return E;function H(K,J,N){return N.subarray(w(K,J)+1,w(K,J)+q+1)}function w(K,J){let N=(K+C[0])%C[0];return(J+C[1])%C[1]*(C[0]*(q+1))+N*(q+1)}function g(K,J,N,O){for(var X=N;X<=O;X=X+1)p(K,J,X);H(K,J,L)[0]=H(K,J,E)[0]}function p(K,J,N){var O=H(K,J,E),X=O[0];if(O<=0)return;let P=K,j=J;for(var $=0;$<N;$=$+1){let y=d(J);P=P-y,j=j-1}var I=[P,j];for(var $=0;$<6;$=$+1){if(X<=0)break;for(var A=0;A<N;A=A+1){if(X<=0){O[0]=0;break}const B=Math.round(O[0]*(1-Q)/(N*6*6));if(B<M*W){X=0;break}X-=B;var k=H(I[0],I[1],L);k[N]+=B,I=a(I[0],I[1],_[$]),console.log(P,j,N,k[N])}}O[0]=X}}var a=function(E,L,C){let q=d(L);if(C[1]==0)return[E+C[0],L];else return[E+C[0]-q,L+C[1]]},d=function(E){return E&1},_=[[1,0],[1,1],[0,1],[-1,0],[0,-1],[1,-1]];async function x(){const E=[64,64],L=1/Math.max(E[0],E[1]),q=await(await navigator.gpu?.requestAdapter())?.requestDevice();if(!q){fail("need a browser that supports WebGPU");return}else console.log("WebGPU is supported");const Q=document.querySelector("canvas"),W=Q.getContext("webgpu"),M=navigator.gpu.getPreferredCanvasFormat();W.configure({device:q,format:M});const F=await fetch("./shaders/hexgrid3d_vertex.wgsl").then((Z)=>Z.text()),R=await fetch("./shaders/hexgrid3d_fragment.wgsl").then((Z)=>Z.text()),T=q.createShaderModule({label:"HexGrid3D vertex shader",code:F}),z=q.createShaderModule({label:"HexGrid3D fragment shader",code:R}),V=8,l=16,U=16,H=100,w=E[0]*E[1]*V,g=U,p=E[0]*E[1]*H,K=q.createBuffer({label:"Hex attributes storage buffer for objects",size:w,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),J=q.createBuffer({label:"global attributes uniform",size:g,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),N=0,O=2;{const Z=new Float32Array(w/4);for(let Y=0;Y<E[0]*E[1];++Y){const v=Y*(V/4);let S=Y%E[0],G=Math.floor(Y/E[0]);G%2==1||(S+=0.5),Z.set([S*Math.sqrt(3)*L,G*3/2*L],v)}q.queue.writeBuffer(K,0,Z)}const X=q.createBuffer({label:"state buffer 0",size:p,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),P=new Int32Array(p/4),j=new Int32Array(p/4);for(let Z=0;Z<E[0]*E[1];++Z){const Y=Z*(H/4);let v=Math.floor(E[0]*E[1]/2+E[0]/2);if(Math.random()<0.01)P.set([1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],Y)}const{vertexData:$,numVertices:I}=s({hexSize:L,center:{x:-1-L,y:-1+L}}),A=q.createBuffer({label:"storage buffer vertices",size:$.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});q.queue.writeBuffer(A,0,$);const k=q.createRenderPipeline({label:"HexGrid3D pipeline",layout:"auto",vertex:{module:T,entryPoint:"vs"},fragment:{module:z,entryPoint:"fs",targets:[{format:M}]}}),y=q.createBindGroup({label:"flip bind group for objects",layout:k.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:K}},{binding:1,resource:{buffer:X}},{binding:2,resource:{buffer:J}},{binding:3,resource:{buffer:A}}]}),B={label:"our basic canvas renderPass",colorAttachments:[{clearValue:[0,0,0,1],loadOp:"clear",storeOp:"store"}]},h=new Float32Array(g/4);function m(Z){var Y=Z;Q.width=Math.max(1,q.limits.maxTextureDimension2D),Q.height=Math.max(1,q.limits.maxTextureDimension2D);const v=Y==1?P:j,S=Y==1?j:P,G=f(v,S,E);B.colorAttachments[0].view=W.getCurrentTexture().createView();const b=q.createCommandEncoder({label:"our simulation renderer encoder"}),D=b.beginRenderPass(B);D.setPipeline(k);const u=Q.width/Q.height,c=1;h.set([c/u,c,E[0],E[1]],0),q.queue.writeBuffer(J,0,h),q.queue.writeBuffer(X,0,G),D.setBindGroup(0,y),D.draw(I,E[0]*E[1]),D.end();const o=b.finish();q.queue.submit([o]),Y=1-Y,setTimeout(()=>{m(Y)},25)}m(1)}var s=function({hexSize:E=0.1,center:L={x:0,y:0}}={}){const q=new Float32Array(36),Q=new Float32Array(12);for(let W=0;W<6;W++){const M=W*2,F=2*Math.PI*((W+0.5)/6);Q[M]=E*Math.cos(F),Q[M+1]=E*Math.sin(F)}for(let W=0;W<6;W++){const M=W*6,F=W*2;q[M+0]=L.x,q[M+1]=L.y,q[M+2]=L.x+Q[F],q[M+3]=L.y+Q[F+1],q[M+4]=L.x+Q[(F+2)%12],q[M+5]=L.y+Q[(F+3)%12]}return{vertexData:q,numVertices:18}};x();