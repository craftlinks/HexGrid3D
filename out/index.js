function d(C,J,L){J.fill(0);for(var E=0;E<L[1];E=E+1)for(var R=0;R<L[0];R=R+1){let Q=C[$(R,E)],N=Z(R,E,C);if(Q>0)N[0]=1000}for(var K=0;K<23;K+=1){for(var E=0;E<L[1];E=E+1)for(var R=0;R<L[0];R=R+1)v(R,E,1,K);for(var E=0;E<L[1];E=E+1)for(var R=0;R<L[0];R=R+1){var F=Z(R,E,J);if(F[K]<6)F[K]=0;if(F[K+1]<6)F[K+1]=0;var h=Z(R,E,C);h[K]=F[K],h[K+1]=F[K+1],F[K]=0,F[K+1]=0}}for(var E=0;E<L[1];E=E+1)for(var R=0;R<L[0];R=R+1){var A=0,P=0;for(var K=0;K<11;K+=1)A+=Z(R,E,C)[K];for(var K=12;K<24;K+=1)P+=Z(R,E,C)[K];if(P=P+A,A>P*0.9)J[$(R,E)]=1;if(A<P*0.9)J[$(R,E)]=0;if(A==P*0.9){if(C[$(R,E)]==0)J[$(R,E)]=0;if(C[$(R,E)]==1)J[$(R,E)]=1}}function Z(Q,N,V){return V.subarray($(Q,N)+1,$(Q,N)+24+1)}function $(Q,N){let V=(Q+L[0])%L[0];return(N+L[1])%L[1]*(L[0]*25)+V*25}function v(Q,N,V,M){var O=Z(Q,N,C);if(O[M]==0)return;let B=Q,g=N;for(var j=0;j<V;j=j+1){let S=u(N);B=B-S,g=g-1}var I=[B,g];let w=O[M];Z(Q,N,J)[M+1]+=Math.round(w*0.92/7),O[M]-=Math.round(w*0.92/7);for(var j=0;j<6;j=j+1)for(var p=0;p<V;p=p+1){if(O[M]<=0)break;let k=Math.floor(Math.random()*5);O[M]-=Math.round(w*0.92/7);var z=Z(I[0],I[1],J);z[M+1]+=Math.round(w*0.92/7),I=a(I[0],I[1],c[k])}O[M]-=w*0.08,z[M]+=w*0.08;while(O[M]>0){let S=Math.floor(Math.random()*6);if(O[M]-=1,S<=5)I=a(Q,N,c[S]),z=Z(I[0],I[1],J),z[M+1]+=1;else z[M]+=1}}return C}var a=function(C,J,L){let q=u(J);if(L[1]==0)return[C+L[0],J];else return[C+L[0]-q,J+L[1]]},u=function(C){return C&1},c=[[1,0],[1,1],[0,1],[-1,0],[0,-1],[1,-1]];async function s(){const C=[100,100],J=1/Math.max(C[0],C[1]),q=await(await navigator.gpu?.requestAdapter())?.requestDevice();if(!q){fail("need a browser that supports WebGPU");return}else console.log("WebGPU is supported");const T=document.querySelector("canvas"),W=T.getContext("webgpu"),X=navigator.gpu.getPreferredCanvasFormat();W.configure({device:q,format:X});const U=await fetch("./shaders/hexgrid3d_vertex.wgsl").then((H)=>H.text()),E=await fetch("./shaders/hexgrid3d_fragment.wgsl").then((H)=>H.text()),R=q.createShaderModule({label:"HexGrid3D vertex shader",code:U}),K=q.createShaderModule({label:"HexGrid3D fragment shader",code:E}),F=8,h=16,A=16,P=100,Z=C[0]*C[1]*F,$=A,v=C[0]*C[1]*P,Q=q.createBuffer({label:"Hex attributes storage buffer for objects",size:Z,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),N=q.createBuffer({label:"global attributes uniform",size:$,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),V=0,M=2;{const H=new Float32Array(Z/4);for(let Y=0;Y<C[0]*C[1];++Y){const D=Y*(F/4);let G=Y%C[0],l=Math.floor(Y/C[0]);l%2==1||(G+=0.5),H.set([G*Math.sqrt(3)*J,l*3/2*J],D)}q.queue.writeBuffer(Q,0,H)}const O=q.createBuffer({label:"state buffer 0",size:v,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),B=new Int32Array(v/4),g=new Int32Array(v/4);for(let H=0;H<C[0]*C[1];++H){const Y=H*(P/4);let D=Math.floor(C[0]*C[1]/2+C[0]/2);if(Math.random()<0.001)B.set([1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],Y)}const{vertexData:j,numVertices:I}=_({hexSize:J,center:{x:-1-J,y:-1+J}}),w=q.createBuffer({label:"storage buffer vertices",size:j.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});q.queue.writeBuffer(w,0,j);const p=q.createRenderPipeline({label:"HexGrid3D pipeline",layout:"auto",vertex:{module:R,entryPoint:"vs"},fragment:{module:K,entryPoint:"fs",targets:[{format:X}]}}),z=q.createBindGroup({label:"flip bind group for objects",layout:p.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:Q}},{binding:1,resource:{buffer:O}},{binding:2,resource:{buffer:N}},{binding:3,resource:{buffer:w}}]}),S={label:"our basic canvas renderPass",colorAttachments:[{clearValue:[0,0,0,1],loadOp:"clear",storeOp:"store"}]},k=new Float32Array($/4);function m(H){var Y=H;T.width=Math.max(1,q.limits.maxTextureDimension2D),T.height=Math.max(1,q.limits.maxTextureDimension2D);const D=Y==1?B:g,G=Y==1?g:B,l=d(D,G,C);S.colorAttachments[0].view=W.getCurrentTexture().createView();const f=q.createCommandEncoder({label:"our simulation renderer encoder"}),y=f.beginRenderPass(S);y.setPipeline(p);const o=T.width/T.height,b=1;k.set([b/o,b,C[0],C[1]],0),q.queue.writeBuffer(N,0,k),q.queue.writeBuffer(O,0,l),y.setBindGroup(0,z),y.draw(I,C[0]*C[1]),y.end();const x=f.finish();q.queue.submit([x]),Y=1-Y,setTimeout(()=>{m(Y)},25)}m(1)}var _=function({hexSize:C=0.1,center:J={x:0,y:0}}={}){const q=new Float32Array(36),T=new Float32Array(12);for(let W=0;W<6;W++){const X=W*2,U=2*Math.PI*((W+0.5)/6);T[X]=C*Math.cos(U),T[X+1]=C*Math.sin(U)}for(let W=0;W<6;W++){const X=W*6,U=W*2;q[X+0]=J.x,q[X+1]=J.y,q[X+2]=J.x+T[U],q[X+3]=J.y+T[U+1],q[X+4]=J.x+T[(U+2)%12],q[X+5]=J.y+T[(U+3)%12]}return{vertexData:q,numVertices:18}};s();