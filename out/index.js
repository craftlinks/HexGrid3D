function d(R,H,J){for(var C=0;C<J[1];C=C+1)for(var E=0;E<J[0];E=E+1){let T=R[Y(E,C)],L=P(E,C,R);if(L.fill(0),T>0)L[0]=1e4}for(var K=0;K<2;K+=1){for(var C=0;C<J[1];C=C+1)for(var E=0;E<J[0];E=E+1)p(E,C,1,K);for(var C=0;C<J[1];C=C+1)for(var E=0;E<J[0];E=E+1){var A=P(E,C,H);if(A[K]<80)A[K]=0;if(A[K+1]<80)A[K+1]=0}}for(var C=0;C<J[1];C=C+1)for(var E=0;E<J[0];E=E+1){var B=0,I=0;for(var K=0;K<0;K+=1)B+=P(E,C,H)[K];for(var K=1;K<2;K+=1)I+=P(E,C,H)[K];if(I=I+B,B>I*0.6)H[Y(E,C)]=1;if(B<I*0.6)H[Y(E,C)]=0;if(B==I*0.6){if(R[Y(E,C)]==0)H[Y(E,C)]=0;if(R[Y(E,C)]==1)H[Y(E,C)]=1}}function P(T,L,U){return U.subarray(Y(T,L)+1,Y(T,L)+2+1)}function Y(T,L){let U=(T+J[0])%J[0];return(L+J[1])%J[1]*(J[0]*3)+U*3}function p(T,L,U,M){var j=P(T,L,R);if(j[M]==0)return;let z=T,V=L;for(var $=0;$<U;$=$+1){let k=u(L);z=z-k,V=V-1}var W=[z,V];let g=j[M];for(var $=0;$<6;$=$+1)for(var S=0;S<U;S=S+1){if(j[M]<=0)break;j[M]-=Math.round(g*0.95/7);var w=P(W[0],W[1],H);w[M+1]+=Math.round(g*0.95/7),W=a(W[0],W[1],c[$])}j[M]-=g*0.05,w[M]+=g*0.05;while(j[M]>0){let k=Math.floor(Math.random()*7);if(j[M]-=1,k<=5)W=a(W[0],W[1],c[k]),w=P(W[0],W[1],H),w[M+1]+=1;else w[M]+=1}}return R}var a=function(R,H,J){let q=u(H);if(J[1]==0)return[R+J[0],H];else return[R+J[0]-q,H+J[1]]},u=function(R){return R&1},c=[[1,0],[1,1],[0,1],[-1,0],[0,-1],[1,-1]];async function s(){const R=[128,128],H=1/Math.max(R[0],R[1]),q=await(await navigator.gpu?.requestAdapter())?.requestDevice();if(!q){fail("need a browser that supports WebGPU");return}else console.log("WebGPU is supported");const N=document.querySelector("canvas"),O=N.getContext("webgpu"),Q=navigator.gpu.getPreferredCanvasFormat();O.configure({device:q,format:Q});const F=await fetch("./shaders/hexgrid3d_vertex.wgsl").then((Z)=>Z.text()),C=await fetch("./shaders/hexgrid3d_fragment.wgsl").then((Z)=>Z.text()),E=q.createShaderModule({label:"HexGrid3D vertex shader",code:F}),K=q.createShaderModule({label:"HexGrid3D fragment shader",code:C}),A=8,B=16,I=16,P=12,Y=R[0]*R[1]*A,p=I,T=R[0]*R[1]*P,L=q.createBuffer({label:"Hex attributes storage buffer for objects",size:Y,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),U=q.createBuffer({label:"global attributes uniform",size:p,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),M=0,j=2;{const Z=new Float32Array(Y/4);for(let X=0;X<R[0]*R[1];++X){const D=X*(A/4);let v=X%R[0],G=Math.floor(X/R[0]);G%2==1||(v+=0.5),Z.set([v*Math.sqrt(3)*H,G*3/2*H],D)}q.queue.writeBuffer(L,0,Z)}const z=q.createBuffer({label:"state buffer 0",size:T,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),V=new Int32Array(T/4),$=new Int32Array(T/4);for(let Z=0;Z<R[0]*R[1];++Z){const X=Z*(P/4);if(Math.random()<0.1)V.set([1,0],X)}const{vertexData:W,numVertices:g}=_({hexSize:H,center:{x:-1-H,y:-1+H}}),S=q.createBuffer({label:"storage buffer vertices",size:W.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});q.queue.writeBuffer(S,0,W);const w=q.createRenderPipeline({label:"HexGrid3D pipeline",layout:"auto",vertex:{module:E,entryPoint:"vs"},fragment:{module:K,entryPoint:"fs",targets:[{format:Q}]}}),k=q.createBindGroup({label:"flip bind group for objects",layout:w.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:L}},{binding:1,resource:{buffer:z}},{binding:2,resource:{buffer:U}},{binding:3,resource:{buffer:S}}]}),l={label:"our basic canvas renderPass",colorAttachments:[{clearValue:[0,0,0,1],loadOp:"clear",storeOp:"store"}]},h=new Float32Array(p/4);function m(Z){var X=Z;N.width=Math.max(1,q.limits.maxTextureDimension2D),N.height=Math.max(1,q.limits.maxTextureDimension2D);const D=X==1?V:$,v=X==1?$:V,G=d(D,v,R);l.colorAttachments[0].view=O.getCurrentTexture().createView();const f=q.createCommandEncoder({label:"our simulation renderer encoder"}),y=f.beginRenderPass(l);y.setPipeline(w);const o=N.width/N.height,b=1;h.set([b/o,b,R[0],R[1]],0),q.queue.writeBuffer(U,0,h),q.queue.writeBuffer(z,0,G),y.setBindGroup(0,k),y.draw(g,R[0]*R[1]),y.end();const x=f.finish();q.queue.submit([x]),X=1-X,setTimeout(()=>{m(X)},1000)}m(1)}var _=function({hexSize:R=0.1,center:H={x:0,y:0}}={}){const q=new Float32Array(36),N=new Float32Array(12);for(let O=0;O<6;O++){const Q=O*2,F=2*Math.PI*((O+0.5)/6);N[Q]=R*Math.cos(F),N[Q+1]=R*Math.sin(F)}for(let O=0;O<6;O++){const Q=O*6,F=O*2;q[Q+0]=H.x,q[Q+1]=H.y,q[Q+2]=H.x+N[F],q[Q+3]=H.y+N[F+1],q[Q+4]=H.x+N[(F+2)%12],q[Q+5]=H.y+N[(F+3)%12]}return{vertexData:q,numVertices:18}};s();