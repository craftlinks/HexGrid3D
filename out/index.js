function d(q,J,L){J.fill(0);for(var H=0;H<L[1];H=H+1)for(var C=0;C<L[0];C=C+1){let R=q[$(C,H)],M=Z(C,H,q);if(R>0)M[0]=1e4}for(var K=0;K<23;K+=1){for(var H=0;H<L[1];H=H+1)for(var C=0;C<L[0];C=C+1)G(C,H,1,K);for(var H=0;H<L[1];H=H+1)for(var C=0;C<L[0];C=C+1){var O=Z(C,H,J);if(O[K]<220)O[K]=0;if(O[K+1]<220)O[K+1]=0;var h=Z(C,H,q);h[K]=O[K],h[K+1]=O[K+1],O[K]=0,O[K+1]=0}}for(var H=0;H<L[1];H=H+1)for(var C=0;C<L[0];C=C+1){var V=0,I=0;for(var K=0;K<11;K+=1)V+=Z(C,H,q)[K];for(var K=12;K<24;K+=1)I+=Z(C,H,q)[K];if(I=I+V,V>I*0.8)J[$(C,H)]=1;if(V<I*0.8)J[$(C,H)]=0;if(V==I*0.8){if(q[$(C,H)]==0)J[$(C,H)]=0;if(q[$(C,H)]==1)J[$(C,H)]=1}}function Z(R,M,B){return B.subarray($(R,M)+1,$(R,M)+24+1)}function $(R,M){let B=(R+L[0])%L[0];return(M+L[1])%L[1]*(L[0]*25)+B*25}function G(R,M,B,N){var F=Z(R,M,q);if(F[N]==0)return;let z=R,p=M;for(var U=0;U<B;U=U+1){let g=u(M);z=z-g,p=p-1}var w=[z,p];let j=F[N];Z(R,M,J)[N+1]+=Math.round(j*0.96/7),F[N]-=Math.round(j*0.96/7);for(var U=0;U<6;U=U+1)for(var v=0;v<B;v=v+1){if(F[N]<=0)break;let l=Math.floor(Math.random()*5);F[N]-=Math.round(j*0.96/7);var S=Z(w[0],w[1],J);S[N+1]+=Math.round(j*0.96/7),w=a(R,M,c[l])}F[N]-=j*0.04,S[N]+=j*0.04;while(F[N]>0){let g=Math.floor(Math.random()*6);if(F[N]-=1,g<=5)w=a(R,M,c[g]),S=Z(w[0],w[1],J),S[N+1]+=1;else S[N]+=1}}return q}var a=function(q,J,L){let E=u(J);if(L[1]==0)return[q+L[0],J];else return[q+L[0]-E,J+L[1]]},u=function(q){return q&1},c=[[1,0],[1,1],[0,1],[-1,0],[0,-1],[1,-1]];async function s(){const q=[80,80],J=1/Math.max(q[0],q[1]),E=await(await navigator.gpu?.requestAdapter())?.requestDevice();if(!E){fail("need a browser that supports WebGPU");return}else console.log("WebGPU is supported");const T=document.querySelector("canvas"),W=T.getContext("webgpu"),X=navigator.gpu.getPreferredCanvasFormat();W.configure({device:E,format:X});const P=await fetch("./shaders/hexgrid3d_vertex.wgsl").then((Q)=>Q.text()),H=await fetch("./shaders/hexgrid3d_fragment.wgsl").then((Q)=>Q.text()),C=E.createShaderModule({label:"HexGrid3D vertex shader",code:P}),K=E.createShaderModule({label:"HexGrid3D fragment shader",code:H}),O=8,h=16,V=16,I=100,Z=q[0]*q[1]*O,$=V,G=q[0]*q[1]*I,R=E.createBuffer({label:"Hex attributes storage buffer for objects",size:Z,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),M=E.createBuffer({label:"global attributes uniform",size:$,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),B=0,N=2;{const Q=new Float32Array(Z/4);for(let Y=0;Y<q[0]*q[1];++Y){const A=Y*(O/4);let k=Y%q[0],D=Math.floor(Y/q[0]);D%2==1||(k+=0.5),Q.set([k*Math.sqrt(3)*J,D*3/2*J],A)}E.queue.writeBuffer(R,0,Q)}const F=E.createBuffer({label:"state buffer 0",size:G,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),z=new Int32Array(G/4),p=new Int32Array(G/4);for(let Q=0;Q<q[0]*q[1];++Q){const Y=Q*(I/4);let A=Math.floor(q[0]*q[1]/2+q[0]/2);if(Q==A||Q==A+1||Q==A+q[0]||Q==A+q[0]+1)z.set([1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],Y)}const{vertexData:U,numVertices:w}=_({hexSize:J,center:{x:-1-J,y:-1+J}}),j=E.createBuffer({label:"storage buffer vertices",size:U.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});E.queue.writeBuffer(j,0,U);const v=E.createRenderPipeline({label:"HexGrid3D pipeline",layout:"auto",vertex:{module:C,entryPoint:"vs"},fragment:{module:K,entryPoint:"fs",targets:[{format:X}]}}),S=E.createBindGroup({label:"flip bind group for objects",layout:v.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:R}},{binding:1,resource:{buffer:F}},{binding:2,resource:{buffer:M}},{binding:3,resource:{buffer:j}}]}),g={label:"our basic canvas renderPass",colorAttachments:[{clearValue:[0,0,0,1],loadOp:"clear",storeOp:"store"}]},l=new Float32Array($/4);function m(Q){var Y=Q;T.width=Math.max(1,E.limits.maxTextureDimension2D),T.height=Math.max(1,E.limits.maxTextureDimension2D);const A=Y==1?z:p,k=Y==1?p:z,D=d(A,k,q);g.colorAttachments[0].view=W.getCurrentTexture().createView();const f=E.createCommandEncoder({label:"our simulation renderer encoder"}),y=f.beginRenderPass(g);y.setPipeline(v);const o=T.width/T.height,b=1;l.set([b/o,b,q[0],q[1]],0),E.queue.writeBuffer(M,0,l),E.queue.writeBuffer(F,0,D),y.setBindGroup(0,S),y.draw(w,q[0]*q[1]),y.end();const x=f.finish();E.queue.submit([x]),Y=1-Y,setTimeout(()=>{m(Y)},25)}m(1)}var _=function({hexSize:q=0.1,center:J={x:0,y:0}}={}){const E=new Float32Array(36),T=new Float32Array(12);for(let W=0;W<6;W++){const X=W*2,P=2*Math.PI*((W+0.5)/6);T[X]=q*Math.cos(P),T[X+1]=q*Math.sin(P)}for(let W=0;W<6;W++){const X=W*6,P=W*2;E[X+0]=J.x,E[X+1]=J.y,E[X+2]=J.x+T[P],E[X+3]=J.y+T[P+1],E[X+4]=J.x+T[(P+2)%12],E[X+5]=J.y+T[(P+3)%12]}return{vertexData:E,numVertices:18}};s();