function c(C,q,K){q.fill(0);for(var E=0;E<K[1];E=E+1)for(var R=0;R<K[0];R=R+1){let M=C[X(R,E)],L=H(R,E,C);if(M>0)L[0]=1000}for(var J=0;J<23;J+=1){for(var E=0;E<K[1];E=E+1)for(var R=0;R<K[0];R=R+1)z(R,E,1,J);for(var E=0;E<K[1];E=E+1)for(var R=0;R<K[0];R=R+1){var $=H(R,E,q);if($[J]<8)$[J]=0;if($[J+1]<8)$[J+1]=0;var l=H(R,E,C);l[J]=$[J],l[J+1]=$[J+1],$[J]=0,$[J+1]=0}}for(var E=0;E<K[1];E=E+1)for(var R=0;R<K[0];R=R+1){var P=0,O=0;for(var J=0;J<11;J+=1)P+=H(R,E,C)[J];for(var J=12;J<24;J+=1)O+=H(R,E,C)[J];if(O=O+P,P>O*0.2)q[X(R,E)]=1;if(P<O*0.2)q[X(R,E)]=0;if(P==O*0.2){if(C[X(R,E)]==0)q[X(R,E)]=0;if(C[X(R,E)]==1)q[X(R,E)]=1}}function H(M,L,A){return A.subarray(X(M,L)+1,X(M,L)+24+1)}function X(M,L){let A=(M+K[0])%K[0];return(L+K[1])%K[1]*(K[0]*25)+A*25}function z(M,L,A,Y){var U=H(M,L,C);if(U[Y]==0)return;let w=M,V=L;for(var B=0;B<A;B=B+1){let k=a(L);w=w-k,V=V-1}var g=[w,V];let I=U[Y];H(M,L,q)[Y+1]+=Math.round(I*0.94/7),U[Y]-=Math.round(I*0.94/7);while(U[Y]>0){let k=Math.floor(Math.random()*5);U[Y]-=Math.round(I*0.94/7);var S=H(g[0],g[1],q);S[Y+1]+=Math.round(I*0.94/7),g=o(M,L,s[k])}U[Y]-=I*0.06,S[Y]+=I*0.06}return C}var o=function(C,q,K){let j=a(q);if(K[1]==0)return[C+K[0],q];else return[C+K[0]-j,q+K[1]]},a=function(C){return C&1},s=[[1,0],[1,1],[0,1],[-1,0],[0,-1],[1,-1]];async function x(){const C=[100,100],q=1/Math.max(C[0],C[1]),j=await(await navigator.gpu?.requestAdapter())?.requestDevice();if(!j){fail("need a browser that supports WebGPU");return}else console.log("WebGPU is supported");const N=document.querySelector("canvas"),Q=N.getContext("webgpu"),T=navigator.gpu.getPreferredCanvasFormat();Q.configure({device:j,format:T});const F=await fetch("./shaders/hexgrid3d_vertex.wgsl").then((Z)=>Z.text()),E=await fetch("./shaders/hexgrid3d_fragment.wgsl").then((Z)=>Z.text()),R=j.createShaderModule({label:"HexGrid3D vertex shader",code:F}),J=j.createShaderModule({label:"HexGrid3D fragment shader",code:E}),$=8,l=16,P=16,O=100,H=C[0]*C[1]*$,X=P,z=C[0]*C[1]*O,M=j.createBuffer({label:"Hex attributes storage buffer for objects",size:H,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),L=j.createBuffer({label:"global attributes uniform",size:X,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),A=0,Y=2;{const Z=new Float32Array(H/4);for(let W=0;W<C[0]*C[1];++W){const v=W*($/4);let p=W%C[0],G=Math.floor(W/C[0]);G%2==1||(p+=0.5),Z.set([p*Math.sqrt(3)*q,G*3/2*q],v)}j.queue.writeBuffer(M,0,Z)}const U=j.createBuffer({label:"state buffer 0",size:z,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),w=new Int32Array(z/4),V=new Int32Array(z/4);for(let Z=0;Z<C[0]*C[1];++Z){const W=Z*(O/4);let v=Math.floor(C[0]*C[1]/2+C[0]/2);if(Math.random()<0.001)w.set([1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],W)}const{vertexData:B,numVertices:g}=_({hexSize:q,center:{x:-1-q,y:-1+q}}),I=j.createBuffer({label:"storage buffer vertices",size:B.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});j.queue.writeBuffer(I,0,B);const S=j.createRenderPipeline({label:"HexGrid3D pipeline",layout:"auto",vertex:{module:R,entryPoint:"vs"},fragment:{module:J,entryPoint:"fs",targets:[{format:T}]}}),k=j.createBindGroup({label:"flip bind group for objects",layout:S.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:M}},{binding:1,resource:{buffer:U}},{binding:2,resource:{buffer:L}},{binding:3,resource:{buffer:I}}]}),y={label:"our basic canvas renderPass",colorAttachments:[{clearValue:[0,0,0,1],loadOp:"clear",storeOp:"store"}]},h=new Float32Array(X/4);function m(Z){var W=Z;N.width=Math.max(1,j.limits.maxTextureDimension2D),N.height=Math.max(1,j.limits.maxTextureDimension2D);const v=W==1?w:V,p=W==1?V:w,G=c(v,p,C);y.colorAttachments[0].view=Q.getCurrentTexture().createView();const f=j.createCommandEncoder({label:"our simulation renderer encoder"}),D=f.beginRenderPass(y);D.setPipeline(S);const d=N.width/N.height,b=1;h.set([b/d,b,C[0],C[1]],0),j.queue.writeBuffer(L,0,h),j.queue.writeBuffer(U,0,G),D.setBindGroup(0,k),D.draw(g,C[0]*C[1]),D.end();const u=f.finish();j.queue.submit([u]),W=1-W,setTimeout(()=>{m(W)},25)}m(1)}var _=function({hexSize:C=0.1,center:q={x:0,y:0}}={}){const j=new Float32Array(36),N=new Float32Array(12);for(let Q=0;Q<6;Q++){const T=Q*2,F=2*Math.PI*((Q+0.5)/6);N[T]=C*Math.cos(F),N[T+1]=C*Math.sin(F)}for(let Q=0;Q<6;Q++){const T=Q*6,F=Q*2;j[T+0]=q.x,j[T+1]=q.y,j[T+2]=q.x+N[F],j[T+3]=q.y+N[F+1],j[T+4]=q.x+N[(F+2)%12],j[T+5]=q.y+N[(F+3)%12]}return{vertexData:j,numVertices:18}};x();