async function x(){let q=0.001,k={dt:q,n:16000,frictionFactor:Math.pow(0.5,q/0.04),rMax:0.25,m:6,opacity:50,particleSize:2};const U=await navigator.gpu?.requestAdapter(),K=navigator?.gpu.getPreferredCanvasFormat(U);let A=await U?.requestDevice();if(!A){fail("need a browser that supports WebGPU");return}else console.log("WebGPU is supported");A.lost.then((y)=>{if(console.error(`WebGPU device was lost: ${y.message}`),A=null,y.reason!=="destroyed")x()});var W=document.querySelector("canvas");const L=await fetch("./shaders/plife_compute.wgsl").then((y)=>y.text()),N=await fetch("./shaders/render.wgsl").then((y)=>y.text());let J=[];for(let y=0;y<k.m;y++){const I=[];for(let E=0;E<k.m;E++)y==E?I.push(1):y==(E+1)%k.m?I.push(0.1):I.push(0);J.push(I)}const T=new Float32Array(J.flat());console.log(T);const z=new Uint32Array(k.n),Y=new Float32Array(k.n*4),$=new Float32Array(k.n*3);for(let y=0;y<k.n;y++)z[y]=y%k.m,Y[4*y]=Math.random()*2-1,Y[4*y+1]=Math.random()*2-1,Y[4*y+2]=Math.random()*2-1,Y[4*y+3]=1,$[3*y]=0,$[3*y+1]=0,$[3*y+2]=0;const w=A.createBuffer({label:"params buffer",size:Object.keys(k).length*4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),j=A.createBuffer({label:"F buffer",size:k.m*k.m*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),F=A.createBuffer({label:"colors buffer",size:k.n*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),V=A.createBuffer({label:"velocities buffer",size:k.n*3*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),H=A.createBuffer({label:"positions buffer",size:k.n*4*4,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC}),n=A.createBuffer({label:"Position buffer result",size:k.n*4*4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});A.queue.writeBuffer(H,0,Y),A.queue.writeBuffer(V,0,$),A.queue.writeBuffer(F,0,z),A.queue.writeBuffer(j,0,T);function h(){A.queue.writeBuffer(w,0,new Float32Array(Object.values(k)))}h();const S=A.createBuffer({size:32,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});A.queue.writeBuffer(S,0,new Float32Array([-1,-1,1,-1,-1,1,1,1]));const X=new Uint8Array(4*k.n);for(let y=0;y<k.n;y+=1){const I=t(360/k.m*z[y],100,50);X[y*4]=I[0],X[y*4+1]=I[1],X[y*4+2]=I[2],X[y*4+3]=Math.floor(k.opacity/100*255)}const b=A.createBuffer({size:X.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});A.queue.writeBuffer(b,0,X);const g=A.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),D=A.createShaderModule({label:"Particle Life Compute Shader",code:L}),C=A.createShaderModule({label:"render shader",code:N}),M=A.createComputePipeline({label:"compute velocities pipeline",layout:"auto",compute:{module:D,entryPoint:"update_velocities"}}),B=A.createComputePipeline({label:"update positions pipeline",layout:"auto",compute:{module:D,entryPoint:"update_positions"}}),R=A.createRenderPipeline({layout:"auto",vertex:{module:C,entryPoint:"vs",buffers:[{arrayStride:8,attributes:[{shaderLocation:0,format:"float32x2",offset:0}]},{arrayStride:4,stepMode:"instance",attributes:[{shaderLocation:1,format:"unorm8x4",offset:0}]},{arrayStride:16,stepMode:"instance",attributes:[{shaderLocation:2,format:"float32x4",offset:0}]}]},fragment:{module:C,entryPoint:"fs",targets:[{format:K,blend:{color:{srcFactor:"one",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]},primitive:{topology:"triangle-strip",stripIndexFormat:"uint32"}}),G=A.createBindGroup({layout:M.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:F}},{binding:1,resource:{buffer:V}},{binding:2,resource:{buffer:H}},{binding:3,resource:{buffer:j}}]}),_=A.createBindGroup({layout:M.getBindGroupLayout(1),entries:[{binding:0,resource:{buffer:w}}]}),l=A.createBindGroup({layout:R.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:g}}]}),Z=m(),P={colorAttachments:[{view:Z.getCurrentTexture().createView(),loadOp:"clear",storeOp:"store",clearValue:[0,0,0,1]}]};function u(y){const I=Z.canvas.width/Z.canvas.height;A.queue.writeBuffer(g,0,new Float32Array([W.width,W.height,k.particleSize,I]));const E=y.beginComputePass();E.setPipeline(M),E.setBindGroup(0,G),E.setBindGroup(1,_),E.dispatchWorkgroups(k.n/64),E.end();const O=y.beginComputePass();O.setPipeline(B),O.setBindGroup(0,G),O.setBindGroup(1,_),O.dispatchWorkgroups(k.n/64),O.end(),P.colorAttachments[0].view=Z.getCurrentTexture().createView();const Q=y.beginRenderPass(P);Q.setPipeline(R),Q.setVertexBuffer(0,S),Q.setVertexBuffer(1,b),Q.setVertexBuffer(2,H),Q.setBindGroup(0,l),Q.draw(4,k.n),Q.end()}async function f(y,I=1){const E=A.createCommandEncoder({label:"our command encoder"});for(let Q=0;Q<I;++Q)u(E);const O=E.finish();A.queue.submit([O])}function v(y){let I=window.devicePixelRatio||1,E=y.getBoundingClientRect();y.width=E.width*I,y.height=E.height*I;let O=y.getContext("webgpu");return O.configure({device:A,format:K}),O}function m(){return v(document.querySelector("canvas"))}while(!0)await f(Z),await new Promise(requestAnimationFrame)}var t=function(q,k,U){k/=100,U/=100;let K=(1-Math.abs(2*U-1))*k,A=K*(1-Math.abs(q/60%2-1)),W=U-K/2,L=0,N=0,J=0;if(0<=q&&q<60)L=K,N=A,J=0;else if(60<=q&&q<120)L=A,N=K,J=0;else if(120<=q&&q<180)L=0,N=K,J=A;else if(180<=q&&q<240)L=0,N=A,J=K;else if(240<=q&&q<300)L=A,N=0,J=K;else if(300<=q&&q<360)L=K,N=0,J=A;return L=Math.round((L+W)*255),N=Math.round((N+W)*255),J=Math.round((J+W)*255),[L,N,J]};x();
