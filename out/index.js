async function v(){const q=[64,64],C=1/Math.max(q[0],q[1]),w=await(await navigator.gpu?.requestAdapter())?.requestDevice();if(!w){fail("need a browser that supports WebGPU");return}else console.log("WebGPU is supported");const k=document.querySelector("canvas"),F=k.getContext("webgpu"),R=navigator.gpu.getPreferredCanvasFormat();F.configure({device:w,format:R});const A=await fetch("./shaders/hexgrid3d_vertex.wgsl").then((j)=>j.text()),B=await fetch("./shaders/hexgrid3d_fragment.wgsl").then((j)=>j.text()),G=await fetch("./shaders/hexgrid3d_compute.wgsl").then((j)=>j.text()),g=w.createShaderModule({label:"HexGrid3D vertex shader",code:A}),b=w.createShaderModule({label:"HexGrid3D fragment shader",code:B}),p=w.createShaderModule({label:"HexGrid3D compute module",code:G}),T=8,X=16,S=16,Y=q[0]*q[1]*T,Z=q[0]*q[1]*X,$=S,H=w.createBuffer({label:"Hex attributes storage buffer for objects",size:Y,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),N=w.createBuffer({label:"colors storage buffer for objects",size:Z,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),Q=w.createBuffer({label:"global attributes uniform",size:$,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),u=0,d=2;{const j=new Float32Array(Y/4);for(let W=0;W<q[0]*q[1];++W){const E=W*(T/4);let L=W%q[0],M=Math.floor(W/q[0]);M%2==1||(L+=0.5),j.set([L*Math.sqrt(3)*C,M*3/2*C],E)}w.queue.writeBuffer(H,0,j)}{const j=new Float32Array(Z/4);for(let W=0;W<q[0]*q[1];++W){const E=W*(X/4);if(j.set([0,0,0,1],E),W==55)j.set([1,0,0,1],E)}w.queue.writeBuffer(N,0,j)}const{vertexData:y,numVertices:D}=m({hexSize:C,center:{x:-1-C,y:-1+C}}),O=w.createBuffer({label:"storage buffer vertices",size:y.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});w.queue.writeBuffer(O,0,y);const U=w.createComputePipeline({label:"compute pipeline",layout:"auto",compute:{module:p,entryPoint:"main"}}),I=w.createRenderPipeline({label:"HexGrid3D pipeline",layout:"auto",vertex:{module:g,entryPoint:"vs"},fragment:{module:b,entryPoint:"fs",targets:[{format:R}]}}),l=w.createBindGroup({label:"bind group for objects",layout:I.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:H}},{binding:1,resource:{buffer:N}},{binding:2,resource:{buffer:Q}},{binding:3,resource:{buffer:O}}]}),f=w.createBindGroup({layout:U.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:Q}},{binding:1,resource:{buffer:N}}]}),P={label:"our basic canvas renderPass",colorAttachments:[{clearValue:[0,0,0,1],loadOp:"clear",storeOp:"store"}]},V=new Float32Array($/4);function _(){P.colorAttachments[0].view=F.getCurrentTexture().createView();const j=w.createCommandEncoder({label:"our first triangle encoder"}),W=j.beginComputePass();W.setPipeline(U),W.setBindGroup(0,f),W.dispatchWorkgroups(q[0],q[1]),W.end();const E=j.beginRenderPass(P);E.setPipeline(I);const L=k.width/k.height,M=1;V.set([M/L,M,q[0],q[1]],0),w.queue.writeBuffer(Q,0,V),E.setBindGroup(0,l),E.draw(D,q[0]*q[1]),E.end();const h=j.finish();w.queue.submit([h])}_(),new ResizeObserver((j)=>{for(let W of j){const E=W.target,L=W.contentBoxSize[0].inlineSize,M=W.contentBoxSize[0].blockSize;E.width=Math.max(1,Math.min(L,w.limits.maxTextureDimension2D)),E.height=Math.max(1,Math.min(M,w.limits.maxTextureDimension2D)),_()}}).observe(k)}var m=function({hexSize:q=0.1,center:C={x:0,y:0}}={}){const J=new Float32Array(36),K=new Float32Array(12);for(let w=0;w<6;w++){const k=w*2,F=2*Math.PI*((w+0.5)/6);K[k]=q*Math.cos(F),K[k+1]=q*Math.sin(F)}for(let w=0;w<6;w++){const k=w*6,F=w*2;J[k+0]=C.x,J[k+1]=C.y,J[k+2]=C.x+K[F],J[k+3]=C.y+K[F+1],J[k+4]=C.x+K[(F+2)%12],J[k+5]=C.y+K[(F+3)%12]}return console.log(J),{vertexData:J,numVertices:18}};v();