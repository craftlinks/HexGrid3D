async function m(){const T=await(await navigator.gpu?.requestAdapter())?.requestDevice();if(!T){fail("need a browser that supports WebGPU");return}else console.log("WebGPU is supported");const Y=document.querySelector("canvas"),K=Y.getContext("webgpu"),Q=navigator.gpu.getPreferredCanvasFormat();K.configure({device:T,format:Q});const j=[500,500],J=1/Math.max(j[0],j[1]),R=4,F=8,z=await fetch("./shaders/hexgrid3d_vertex.wgsl").then((E)=>E.text()),b=await fetch("./shaders/hexgrid3d_fragment.wgsl").then((E)=>E.text()),G=await fetch("./shaders/hexgrid3d_compute.wgsl").then((E)=>E.text()),g=T.createShaderModule({label:"HexGrid3D vertex shader",code:z}),D=T.createShaderModule({label:"HexGrid3D fragment shader",code:b}),p=T.createShaderModule({label:"HexGrid3D compute module",code:G}),H=T.createRenderPipeline({label:"HexGrid3D pipeline",layout:"auto",vertex:{module:g,entryPoint:"vs"},fragment:{module:D,entryPoint:"fs",targets:[{format:Q}]}}),S=T.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),L=T.createComputePipeline({label:"compute pipeline",layout:T.createPipelineLayout({bindGroupLayouts:[S]}),compute:{module:p,entryPoint:"main",constants:{blockSize:F}}}),O=8,k=16,l=16,U=j[0]*j[1]*O,y=j[0]*j[1]*k,I=l,V=T.createBuffer({label:"Hex attributes storage buffer for objects",size:U,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),Z=T.createBuffer({label:"colors storage buffer for objects",size:y,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),$=T.createBuffer({label:"global attributes uniform",size:I,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),x=0,c=2;{const E=new Float32Array(U/4);for(let q=0;q<j[0]*j[1];++q){const M=q*(O/4);let W=q%j[0],X=Math.floor(q/j[0]);X%2==1||(W+=0.5),E.set([W*Math.sqrt(3)*J,X*3/2*J],M)}T.queue.writeBuffer(V,0,E)}{const E=new Float32Array(y/4);for(let q=0;q<j[0]*j[1];++q){const M=q*(k/4);E.set([C(0,0.5),C(0,0.5),C(0,0.5),1],M)}T.queue.writeBuffer(Z,0,E)}const P=new Float32Array(I/4),{vertexData:_,numVertices:f}=d({hexSize:J,center:{x:-1-J,y:-1+J}}),B=T.createBuffer({label:"storage buffer vertices",size:_.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});T.queue.writeBuffer(B,0,_);const h=T.createBindGroup({label:"bind group for objects",layout:H.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:V}},{binding:1,resource:{buffer:Z}},{binding:2,resource:{buffer:$}},{binding:3,resource:{buffer:B}}]}),v=T.createBindGroup({layout:L.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:$}},{binding:1,resource:{buffer:Z}}]}),A={label:"our basic canvas renderPass",colorAttachments:[{clearValue:[0,0,0,1],loadOp:"clear",storeOp:"store"}]};function w(){A.colorAttachments[0].view=K.getCurrentTexture().createView();const E=T.createCommandEncoder({label:"our first triangle encoder"}),q=E.beginComputePass();q.setPipeline(L),q.setBindGroup(0,v),q.dispatchWorkgroups(j[0]*j[1]/F,1,1),q.end();const M=E.beginRenderPass(A);M.setPipeline(H);const W=Y.width/Y.height,X=1;P.set([X/W,X,j[0],j[1]],0),T.queue.writeBuffer($,0,P),M.setBindGroup(0,h),M.draw(f,j[0]*j[1]),M.end();const u=E.finish();T.queue.submit([u]),requestAnimationFrame(w)}w(),new ResizeObserver((E)=>{for(let q of E){const M=q.target,W=q.contentBoxSize[0].inlineSize,X=q.contentBoxSize[0].blockSize;M.width=Math.max(1,Math.min(W,T.limits.maxTextureDimension2D)),M.height=Math.max(1,Math.min(X,T.limits.maxTextureDimension2D)),w()}}).observe(Y)}var d=function({hexSize:N=0.1,center:T={x:0,y:0}}={}){const K=new Float32Array(36),Q=new Float32Array(12);for(let j=0;j<6;j++){const J=j*2,R=2*Math.PI*((j+0.5)/6);Q[J]=N*Math.cos(R),Q[J+1]=N*Math.sin(R)}for(let j=0;j<6;j++){const J=j*6,R=j*2;K[J+0]=T.x,K[J+1]=T.y,K[J+2]=T.x+Q[R],K[J+3]=T.y+Q[R+1],K[J+4]=T.x+Q[(R+2)%12],K[J+5]=T.y+Q[(R+3)%12]}return console.log(K),{vertexData:K,numVertices:18}};m();var C=(N,T)=>{if(N===void 0)N=0,T=1;else if(T===void 0)T=N,N=0;return N+Math.random()*(T-N)};
