async function g(){let N=0.01,A={dt:N,n:9600,frictionFactor:Math.pow(0.5,N/0.04),rMax:0.2,m:6},k=await(await navigator.gpu?.requestAdapter())?.requestDevice();if(!k){fail("need a browser that supports WebGPU");return}else console.log("WebGPU is supported");k.lost.then((C)=>{if(console.error(`WebGPU device was lost: ${C.message}`),k=null,C.reason!=="destroyed")g()});var B=document.querySelector("canvas");const z=await fetch("./shaders/plife_compute.wgsl").then((C)=>C.text());let O=[];for(let C=0;C<A.m;C++){const L=[];for(let W=0;W<A.m;W++)C==W?L.push(1):C==(W+1)%A.m?L.push(0.1):L.push(0);O.push(L)}const Q=new Float32Array(O.flat());console.log(Q);const H=new Uint32Array(A.n),y=new Float32Array(A.n*3),D=new Float32Array(A.n*3);for(let C=0;C<A.n;C++)H[C]=C%A.m,y[3*C]=Math.random(),y[3*C+1]=Math.random(),y[3*C+2]=Math.random(),D[3*C]=0,D[3*C+1]=0,D[3*C+2]=0;const T=k.createBuffer({label:"params buffer",size:Object.keys(A).length*4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),U=k.createBuffer({label:"F buffer",size:A.m*A.m*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),X=k.createBuffer({label:"colors buffer",size:A.n*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),Y=k.createBuffer({label:"velocities buffer",size:A.n*3*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),I=k.createBuffer({label:"positions buffer",size:A.n*3*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC}),q=k.createBuffer({label:"Position buffer result",size:A.n*3*4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});k.queue.writeBuffer(I,0,y),k.queue.writeBuffer(Y,0,D),k.queue.writeBuffer(X,0,H),k.queue.writeBuffer(U,0,Q);function G(){k.queue.writeBuffer(T,0,new Float32Array(Object.values(A)))}G();const Z=k.createShaderModule({label:"Particle Life Compute Shader",code:z}),J=k.createComputePipeline({label:"compute velocities pipeline",layout:"auto",compute:{module:Z,entryPoint:"update_velocities"}}),u=k.createComputePipeline({label:"update positions pipeline",layout:"auto",compute:{module:Z,entryPoint:"update_positions"}}),F=k.createBindGroup({layout:J.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:X}},{binding:1,resource:{buffer:Y}},{binding:2,resource:{buffer:I}},{binding:3,resource:{buffer:U}}]}),S=k.createBindGroup({layout:J.getBindGroupLayout(1),entries:[{binding:0,resource:{buffer:T}}]});function V(C){const L=C.beginComputePass();L.setPipeline(J),L.setBindGroup(0,F),L.setBindGroup(1,S),L.dispatchWorkgroups(A.n/64),L.end()}async function j(C,L=1){const W=k.createCommandEncoder({label:"our command encoder"});for(let b=0;b<L;++b)V(W);W.copyBufferToBuffer(I,0,q,0,q.size);const E=W.finish();k.queue.submit([E]),await q.mapAsync(GPUMapMode.READ);const $=new Float32Array(q.getMappedRange()),{width:K,height:M}=C.canvas;C.resetTransform(),C.clearRect(0,0,K,M),C.lineWidth=0.1,C.fillStyle="black",C.fillRect(0,0,K,M);for(let b=0;b<A.n;++b){C.beginPath();let _=$[b*3]*K,h=$[b*3+1]*M;C.arc(_,h,3,0,Math.PI*2),C.fillStyle=`hsl(${H[b]*360/A.m}, 100%, 50%)`,C.fill()}await q.unmap()}function P(C){let L=window.devicePixelRatio||1,W=C.getBoundingClientRect();C.width=W.width*L,C.height=W.height*L;let E=C.getContext("2d");return E.scale(L,L),E}function R(){return P(document.querySelector("canvas"))}const w=R();while(!0)await j(w),await new Promise(requestAnimationFrame)}g();
