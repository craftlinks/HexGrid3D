function d(C,q,K){for(var E=0;E<K[1];E=E+1)for(var L=0;L<K[0];L=L+1){let Q=C[Z(L,E)];q.fill(0);let $=Y(L,E,C);if(Q>0)$[0]=1e4}for(var J=0;J<23;J+=1){for(var E=0;E<K[1];E=E+1)for(var L=0;L<K[0];L=L+1)k(L,E,1,J);for(var E=0;E<K[1];E=E+1)for(var L=0;L<K[0];L=L+1){var O=Y(L,E,q);if(O[J]<80)O[J]=0;if(O[J+1]<80)O[J+1]=0;var y=Y(L,E,C);y[J]=O[J],y[J+1]=O[J+1],O[J]=0,O[J+1]=0}}for(var E=0;E<K[1];E=E+1)for(var L=0;L<K[0];L=L+1){var B=0,P=0;for(var J=0;J<11;J+=1)B+=Y(L,E,C)[J];for(var J=12;J<24;J+=1)P+=Y(L,E,C)[J];if(P=P+B,B>P*0.6)q[Z(L,E)]=1;if(B<P*0.6)q[Z(L,E)]=0;if(B==P*0.6){if(C[Z(L,E)]==0)q[Z(L,E)]=0;if(C[Z(L,E)]==1)q[Z(L,E)]=1}}Y(L,E,C).fill(0);function Y(Q,$,z){return z.subarray(Z(Q,$)+1,Z(Q,$)+24+1)}function Z(Q,$){let z=(Q+K[0])%K[0];return($+K[1])%K[1]*(K[0]*25)+z*25}function k(Q,$,z,M){var F=Y(Q,$,C);if(F[M]==0)return;let g=Q,p=$;for(var I=0;I<z;I=I+1){let S=u($);g=g-S,p=p-1}var U=[g,p];let w=F[M];Y(Q,$,q)[M+1]+=Math.round(w*0.95/7),F[M]-=Math.round(w*0.95/7);for(var I=0;I<6;I=I+1)for(var v=0;v<z;v=v+1){if(F[M]<=0)break;F[M]-=Math.round(w*0.95/7);var A=Y(U[0],U[1],q);A[M+1]+=Math.round(w*0.95/7),U=a(U[0],U[1],c[I])}F[M]-=w*0.05,A[M]+=w*0.05;while(F[M]>0){let S=Math.floor(Math.random()*7);if(F[M]-=1,S<=5)U=a(Q,$,c[S]),A=Y(U[0],U[1],q),A[M+1]+=1;else A[M]+=1}}return C}var a=function(C,q,K){let R=u(q);if(K[1]==0)return[C+K[0],q];else return[C+K[0]-R,q+K[1]]},u=function(C){return C&1},c=[[1,0],[1,1],[0,1],[-1,0],[0,-1],[1,-1]];async function s(){const C=[100,100],q=1/Math.max(C[0],C[1]),R=await(await navigator.gpu?.requestAdapter())?.requestDevice();if(!R){fail("need a browser that supports WebGPU");return}else console.log("WebGPU is supported");const T=document.querySelector("canvas"),W=T.getContext("webgpu"),X=navigator.gpu.getPreferredCanvasFormat();W.configure({device:R,format:X});const j=await fetch("./shaders/hexgrid3d_vertex.wgsl").then((N)=>N.text()),E=await fetch("./shaders/hexgrid3d_fragment.wgsl").then((N)=>N.text()),L=R.createShaderModule({label:"HexGrid3D vertex shader",code:j}),J=R.createShaderModule({label:"HexGrid3D fragment shader",code:E}),O=8,y=16,B=16,P=100,h=C[0]*C[1]*O,Y=B,Z=C[0]*C[1]*P,k=R.createBuffer({label:"Hex attributes storage buffer for objects",size:h,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),Q=R.createBuffer({label:"global attributes uniform",size:Y,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),$=0,z=2;{const N=new Float32Array(h/4);for(let H=0;H<C[0]*C[1];++H){const V=H*(O/4);let G=H%C[0],D=Math.floor(H/C[0]);D%2==1||(G+=0.5),N.set([G*Math.sqrt(3)*q,D*3/2*q],V)}R.queue.writeBuffer(k,0,N)}const M=R.createBuffer({label:"state buffer 0",size:Z,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),F=new Int32Array(Z/4),g=new Int32Array(Z/4);for(let N=0;N<C[0]*C[1];++N){const H=N*(P/4);let V=Math.floor(C[0]*C[1]/2+C[0]/2);if(N==V||N==V+1||N==V+C[0]||N==V+C[0]+1)F.set([1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],H)}const{vertexData:p,numVertices:I}=_({hexSize:q,center:{x:-1-q,y:-1+q}}),U=R.createBuffer({label:"storage buffer vertices",size:p.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});R.queue.writeBuffer(U,0,p);const w=R.createRenderPipeline({label:"HexGrid3D pipeline",layout:"auto",vertex:{module:L,entryPoint:"vs"},fragment:{module:J,entryPoint:"fs",targets:[{format:X}]}}),v=R.createBindGroup({label:"flip bind group for objects",layout:w.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:k}},{binding:1,resource:{buffer:M}},{binding:2,resource:{buffer:Q}},{binding:3,resource:{buffer:U}}]}),A={label:"our basic canvas renderPass",colorAttachments:[{clearValue:[0,0,0,1],loadOp:"clear",storeOp:"store"}]},S=new Float32Array(Y/4);function m(N){var H=N;T.width=Math.max(1,R.limits.maxTextureDimension2D),T.height=Math.max(1,R.limits.maxTextureDimension2D);const V=H==1?F:g,G=H==1?g:F,D=d(V,G,C);A.colorAttachments[0].view=W.getCurrentTexture().createView();const f=R.createCommandEncoder({label:"our simulation renderer encoder"}),l=f.beginRenderPass(A);l.setPipeline(w);const o=T.width/T.height,b=1;S.set([b/o,b,C[0],C[1]],0),R.queue.writeBuffer(Q,0,S),R.queue.writeBuffer(M,0,D),l.setBindGroup(0,v),l.draw(I,C[0]*C[1]),l.end();const x=f.finish();R.queue.submit([x]),H=1-H,setTimeout(()=>{m(H)},50)}m(1)}var _=function({hexSize:C=0.1,center:q={x:0,y:0}}={}){const R=new Float32Array(36),T=new Float32Array(12);for(let W=0;W<6;W++){const X=W*2,j=2*Math.PI*((W+0.5)/6);T[X]=C*Math.cos(j),T[X+1]=C*Math.sin(j)}for(let W=0;W<6;W++){const X=W*6,j=W*2;R[X+0]=q.x,R[X+1]=q.y,R[X+2]=q.x+T[j],R[X+3]=q.y+T[j+1],R[X+4]=q.x+T[(j+2)%12],R[X+5]=q.y+T[(j+3)%12]}return{vertexData:R,numVertices:18}};s();