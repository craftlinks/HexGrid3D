function d(R,E,K){E.fill(0);for(var q=0;q<K[1];q=q+1)for(var H=0;H<K[0];H=H+1){let Q=R[$(H,q)],N=Z(H,q,R);if(Q>0)N[0]=1e4}for(var J=0;J<23;J+=1){for(var q=0;q<K[1];q=q+1)for(var H=0;H<K[0];H=H+1)G(H,q,1,J);for(var q=0;q<K[1];q=q+1)for(var H=0;H<K[0];H=H+1){var O=Z(H,q,E);if(O[J]<80)O[J]=0;if(O[J+1]<80)O[J+1]=0;var h=Z(H,q,R);h[J]=O[J],h[J+1]=O[J+1],O[J]=0,O[J+1]=0}}for(var q=0;q<K[1];q=q+1)for(var H=0;H<K[0];H=H+1){var V=0,j=0;for(var J=0;J<11;J+=1)V+=Z(H,q,R)[J];for(var J=12;J<24;J+=1)j+=Z(H,q,R)[J];if(j=j+V,V>j*0.6)E[$(H,q)]=1;if(V<j*0.6)E[$(H,q)]=0;if(V==j*0.6){if(R[$(H,q)]==0)E[$(H,q)]=0;if(R[$(H,q)]==1)E[$(H,q)]=1}}function Z(Q,N,B){return B.subarray($(Q,N)+1,$(Q,N)+24+1)}function $(Q,N){let B=(Q+K[0])%K[0];return(N+K[1])%K[1]*(K[0]*25)+B*25}function G(Q,N,B,L){var F=Z(Q,N,R);if(F[L]==0)return;let z=Q,p=N;for(var U=0;U<B;U=U+1){let g=u(N);z=z-g,p=p-1}var I=[z,p];let w=F[L];Z(Q,N,E)[L+1]+=Math.round(w*0.95/7),F[L]-=Math.round(w*0.95/7);for(var U=0;U<6;U=U+1)for(var v=0;v<B;v=v+1){if(F[L]<=0)break;let D=Math.floor(Math.random()*5);F[L]-=Math.round(w*0.95/7);var S=Z(I[0],I[1],E);S[L+1]+=Math.round(w*0.95/7),I=a(I[0],I[1],c[D])}F[L]-=w*0.05,S[L]+=w*0.05;while(F[L]>0){let g=Math.floor(Math.random()*6);if(F[L]-=1,g<=5)I=a(Q,N,c[g]),S=Z(I[0],I[1],E),S[L+1]+=1;else S[L]+=1}}return R}var a=function(R,E,K){let C=u(E);if(K[1]==0)return[R+K[0],E];else return[R+K[0]-C,E+K[1]]},u=function(R){return R&1},c=[[1,0],[1,1],[0,1],[-1,0],[0,-1],[1,-1]];async function s(){const R=[80,80],E=1/Math.max(R[0],R[1]),C=await(await navigator.gpu?.requestAdapter())?.requestDevice();if(!C){fail("need a browser that supports WebGPU");return}else console.log("WebGPU is supported");const T=document.querySelector("canvas"),W=T.getContext("webgpu"),X=navigator.gpu.getPreferredCanvasFormat();W.configure({device:C,format:X});const P=await fetch("./shaders/hexgrid3d_vertex.wgsl").then((M)=>M.text()),q=await fetch("./shaders/hexgrid3d_fragment.wgsl").then((M)=>M.text()),H=C.createShaderModule({label:"HexGrid3D vertex shader",code:P}),J=C.createShaderModule({label:"HexGrid3D fragment shader",code:q}),O=8,h=16,V=16,j=100,Z=R[0]*R[1]*O,$=V,G=R[0]*R[1]*j,Q=C.createBuffer({label:"Hex attributes storage buffer for objects",size:Z,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),N=C.createBuffer({label:"global attributes uniform",size:$,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),B=0,L=2;{const M=new Float32Array(Z/4);for(let Y=0;Y<R[0]*R[1];++Y){const A=Y*(O/4);let k=Y%R[0],l=Math.floor(Y/R[0]);l%2==1||(k+=0.5),M.set([k*Math.sqrt(3)*E,l*3/2*E],A)}C.queue.writeBuffer(Q,0,M)}const F=C.createBuffer({label:"state buffer 0",size:G,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),z=new Int32Array(G/4),p=new Int32Array(G/4);for(let M=0;M<R[0]*R[1];++M){const Y=M*(j/4);let A=Math.floor(R[0]*R[1]/2+R[0]/2);if(M==A||M==A+1||M==A+R[0]||M==A+R[0]+1)z.set([1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],Y)}const{vertexData:U,numVertices:I}=_({hexSize:E,center:{x:-1-E,y:-1+E}}),w=C.createBuffer({label:"storage buffer vertices",size:U.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});C.queue.writeBuffer(w,0,U);const v=C.createRenderPipeline({label:"HexGrid3D pipeline",layout:"auto",vertex:{module:H,entryPoint:"vs"},fragment:{module:J,entryPoint:"fs",targets:[{format:X}]}}),S=C.createBindGroup({label:"flip bind group for objects",layout:v.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:Q}},{binding:1,resource:{buffer:F}},{binding:2,resource:{buffer:N}},{binding:3,resource:{buffer:w}}]}),g={label:"our basic canvas renderPass",colorAttachments:[{clearValue:[0,0,0,1],loadOp:"clear",storeOp:"store"}]},D=new Float32Array($/4);function m(M){var Y=M;T.width=Math.max(1,C.limits.maxTextureDimension2D),T.height=Math.max(1,C.limits.maxTextureDimension2D);const A=Y==1?z:p,k=Y==1?p:z,l=d(A,k,R);g.colorAttachments[0].view=W.getCurrentTexture().createView();const f=C.createCommandEncoder({label:"our simulation renderer encoder"}),y=f.beginRenderPass(g);y.setPipeline(v);const o=T.width/T.height,b=1;D.set([b/o,b,R[0],R[1]],0),C.queue.writeBuffer(N,0,D),C.queue.writeBuffer(F,0,l),y.setBindGroup(0,S),y.draw(I,R[0]*R[1]),y.end();const x=f.finish();C.queue.submit([x]),Y=1-Y,setTimeout(()=>{m(Y)},25)}m(1)}var _=function({hexSize:R=0.1,center:E={x:0,y:0}}={}){const C=new Float32Array(36),T=new Float32Array(12);for(let W=0;W<6;W++){const X=W*2,P=2*Math.PI*((W+0.5)/6);T[X]=R*Math.cos(P),T[X+1]=R*Math.sin(P)}for(let W=0;W<6;W++){const X=W*6,P=W*2;C[X+0]=E.x,C[X+1]=E.y,C[X+2]=E.x+T[P],C[X+3]=E.y+T[P+1],C[X+4]=E.x+T[(P+2)%12],C[X+5]=E.y+T[(P+3)%12]}return{vertexData:C,numVertices:18}};s();