async function c(){const C=[256,256],M=1/Math.max(C[0],C[1]),k=await(await navigator.gpu?.requestAdapter())?.requestDevice();if(!k){fail("need a browser that supports WebGPU");return}else console.log("WebGPU is supported");const j=document.querySelector("canvas"),E=j.getContext("webgpu"),F=navigator.gpu.getPreferredCanvasFormat();E.configure({device:k,format:F});const g=await fetch("./shaders/hexgrid3d_vertex.wgsl").then((q)=>q.text()),B=await fetch("./shaders/hexgrid3d_fragment.wgsl").then((q)=>q.text()),D=await fetch("./shaders/hexgrid3d_compute.wgsl").then((q)=>q.text()),S=k.createShaderModule({label:"HexGrid3D vertex shader",code:g}),h=k.createShaderModule({label:"HexGrid3D fragment shader",code:B}),p=k.createShaderModule({label:"HexGrid3D compute module",code:D}),O=8,U=16,v=16,I=C[0]*C[1]*O,W=C[0]*C[1]*U,P=v,X=k.createBuffer({label:"Hex attributes storage buffer for objects",size:I,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),R=k.createBuffer({label:"flip colors storage buffer for objects",size:W,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),Y=k.createBuffer({label:"flop colors storage buffer for objects",size:W,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),Q=k.createBuffer({label:"global attributes uniform",size:P,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),s=0,t=2;{const q=new Float32Array(I/4);for(let w=0;w<C[0]*C[1];++w){const K=w*(O/4);let J=w%C[0],L=Math.floor(w/C[0]);L%2==1||(J+=0.5),q.set([J*Math.sqrt(3)*M,L*3/2*M],K)}k.queue.writeBuffer(X,0,q)}{const q=new Float32Array(W/4);for(let w=0;w<C[0]*C[1];++w){const K=w*(U/4);q.set([0,0,0,1],K);let J=Math.floor(w/C[0]),L=w%C[0];if(T(1)>0.999)q.set([T(0.5),T(0.5),T(0.5),1],K)}k.queue.writeBuffer(R,0,q)}const{vertexData:V,numVertices:l}=o({hexSize:M,center:{x:-1-M,y:-1+M}}),Z=k.createBuffer({label:"storage buffer vertices",size:V.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});k.queue.writeBuffer(Z,0,V);const $=k.createComputePipeline({label:"compute pipeline",layout:"auto",compute:{module:p,entryPoint:"main"}}),y=k.createRenderPipeline({label:"HexGrid3D pipeline",layout:"auto",vertex:{module:S,entryPoint:"vs"},fragment:{module:h,entryPoint:"fs",targets:[{format:F}]}}),m=k.createBindGroup({label:"flip bind group for objects",layout:y.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:X}},{binding:1,resource:{buffer:R}},{binding:2,resource:{buffer:Q}},{binding:3,resource:{buffer:Z}}]}),u=k.createBindGroup({label:"flop bind group for objects",layout:y.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:X}},{binding:1,resource:{buffer:Y}},{binding:2,resource:{buffer:Q}},{binding:3,resource:{buffer:Z}}]}),f=k.createBindGroup({layout:$.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:Q}},{binding:1,resource:{buffer:R}},{binding:2,resource:{buffer:Y}}]}),d=k.createBindGroup({layout:$.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:Q}},{binding:1,resource:{buffer:Y}},{binding:2,resource:{buffer:R}}]}),A={label:"our basic canvas renderPass",colorAttachments:[{clearValue:[0,0,0,1],loadOp:"clear",storeOp:"store"}]},z=new Float32Array(P/4);function G(q){var w=q;j.width=Math.max(1,k.limits.maxTextureDimension2D),j.height=Math.max(1,k.limits.maxTextureDimension2D),A.colorAttachments[0].view=E.getCurrentTexture().createView();const K=k.createCommandEncoder({label:"our first triangle encoder"}),J=K.beginComputePass();J.setPipeline($),J.setBindGroup(0,q?f:d),J.dispatchWorkgroups(C[0]/4,C[1]/4),J.end();const L=K.beginRenderPass(A);L.setPipeline(y);const x=j.width/j.height,b=1;z.set([b/x,b,C[0],C[1]],0),k.queue.writeBuffer(Q,0,z),L.setBindGroup(0,q?m:u),L.draw(l,C[0]*C[1]),L.end();const a=K.finish();k.queue.submit([a]),w=1-w,setTimeout(()=>{G(w)},50)}G(1)}var o=function({hexSize:C=0.1,center:M={x:0,y:0}}={}){const H=new Float32Array(36),N=new Float32Array(12);for(let k=0;k<6;k++){const j=k*2,E=2*Math.PI*((k+0.5)/6);N[j]=C*Math.cos(E),N[j+1]=C*Math.sin(E)}for(let k=0;k<6;k++){const j=k*6,E=k*2;H[j+0]=M.x,H[j+1]=M.y,H[j+2]=M.x+N[E],H[j+3]=M.y+N[E+1],H[j+4]=M.x+N[(E+2)%12],H[j+5]=M.y+N[(E+3)%12]}return console.log(H),{vertexData:H,numVertices:18}};c();var T=(C,M)=>{if(C===void 0)C=0,M=1;else if(M===void 0)M=C,C=0;return C+Math.random()*(M-C)};
