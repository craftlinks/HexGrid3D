async function o(){const L=[10,10],M=1/Math.max(L[0],L[1]),w=await(await navigator.gpu?.requestAdapter())?.requestDevice();if(!w){fail("need a browser that supports WebGPU");return}else console.log("WebGPU is supported");const k=document.querySelector("canvas"),q=k.getContext("webgpu"),E=navigator.gpu.getPreferredCanvasFormat();q.configure({device:w,format:E});const J=await fetch("./shaders/hexgrid3d_vertex.wgsl").then((j)=>j.text()),B=await fetch("./shaders/hexgrid3d_fragment.wgsl").then((j)=>j.text()),S=await fetch("./shaders/hexgrid3d_compute.wgsl").then((j)=>j.text()),p=w.createShaderModule({label:"HexGrid3D vertex shader",code:J}),D=w.createShaderModule({label:"HexGrid3D fragment shader",code:B}),h=w.createShaderModule({label:"HexGrid3D compute module",code:S}),y=8,F=16,v=16,l=96,O=L[0]*L[1]*y,W=L[0]*L[1]*F,U=v,I=L[0]*L[1]*l,X=w.createBuffer({label:"Hex attributes storage buffer for objects",size:O,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),T=w.createBuffer({label:"flip colors storage buffer for objects",size:W,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),Y=w.createBuffer({label:"flop colors storage buffer for objects",size:W,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),R=w.createBuffer({label:"global attributes uniform",size:U,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),P=w.createBuffer({label:"state buffer 0",size:I,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),V=w.createBuffer({label:"state buffer 1",size:I,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),n=0,t=2;{const j=new Float32Array(O/4);for(let C=0;C<L[0]*L[1];++C){const N=C*(y/4);let K=C%L[0],Q=Math.floor(C/L[0]);Q%2==1||(K+=0.5),j.set([K*Math.sqrt(3)*M,Q*3/2*M],N)}w.queue.writeBuffer(X,0,j)}{const j=new Float32Array(W/4);for(let C=0;C<L[0]*L[1];++C){const N=C*(F/4);j.set([0,0,0,1],N);let K=Math.floor(C/L[0]),Q=C%L[0];if(C==L[0]*L[1]/2+L[0]/2)j.set([1,1,1,1],N)}w.queue.writeBuffer(T,0,j)}const{vertexData:A,numVertices:m}=s({hexSize:M,center:{x:-1-M,y:-1+M}}),Z=w.createBuffer({label:"storage buffer vertices",size:A.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});w.queue.writeBuffer(Z,0,A);const $=w.createComputePipeline({label:"compute pipeline",layout:"auto",compute:{module:h,entryPoint:"main"}}),H=w.createRenderPipeline({label:"HexGrid3D pipeline",layout:"auto",vertex:{module:p,entryPoint:"vs"},fragment:{module:D,entryPoint:"fs",targets:[{format:E}]}}),u=w.createBindGroup({label:"flip bind group for objects",layout:H.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:X}},{binding:1,resource:{buffer:T}},{binding:2,resource:{buffer:R}},{binding:3,resource:{buffer:Z}}]}),f=w.createBindGroup({label:"flop bind group for objects",layout:H.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:X}},{binding:1,resource:{buffer:Y}},{binding:2,resource:{buffer:R}},{binding:3,resource:{buffer:Z}}]}),d=w.createBindGroup({layout:$.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:R}},{binding:1,resource:{buffer:T}},{binding:2,resource:{buffer:Y}},{binding:3,resource:{buffer:P}},{binding:4,resource:{buffer:V}}]}),c=w.createBindGroup({layout:$.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:R}},{binding:1,resource:{buffer:Y}},{binding:2,resource:{buffer:T}},{binding:3,resource:{buffer:V}},{binding:4,resource:{buffer:P}}]}),g={label:"our basic canvas renderPass",colorAttachments:[{clearValue:[0,0,0,1],loadOp:"clear",storeOp:"store"}]},z=new Float32Array(U/4);function b(j){var C=j;k.width=Math.max(1,w.limits.maxTextureDimension2D),k.height=Math.max(1,w.limits.maxTextureDimension2D),g.colorAttachments[0].view=q.getCurrentTexture().createView();const N=w.createCommandEncoder({label:"our first triangle encoder"}),K=N.beginComputePass();K.setPipeline($),K.setBindGroup(0,j?d:c),K.dispatchWorkgroups(L[0],L[1]),K.end();const Q=N.beginRenderPass(g);Q.setPipeline(H);const x=k.width/k.height,G=1;z.set([G/x,G,L[0],L[1]],0),w.queue.writeBuffer(R,0,z),Q.setBindGroup(0,j?u:f),Q.draw(m,L[0]*L[1]),Q.end();const a=N.finish();w.queue.submit([a]),C=1-C,setTimeout(()=>{b(C)},500)}b(1)}var s=function({hexSize:L=0.1,center:M={x:0,y:0}}={}){const w=new Float32Array(36),k=new Float32Array(12);for(let q=0;q<6;q++){const E=q*2,J=2*Math.PI*((q+0.5)/6);k[E]=L*Math.cos(J),k[E+1]=L*Math.sin(J)}for(let q=0;q<6;q++){const E=q*6,J=q*2;w[E+0]=M.x,w[E+1]=M.y,w[E+2]=M.x+k[J],w[E+3]=M.y+k[J+1],w[E+4]=M.x+k[(J+2)%12],w[E+5]=M.y+k[(J+3)%12]}return console.log(w),{vertexData:w,numVertices:18}};o();