async function w(){let D={dt:0.02,n:1500,frictionFactor:Math.pow(0.5,dt/0.04),rMax:0.25,m:6},I=await(await navigator.gpu?.requestAdapter())?.requestDevice();if(!I){fail("need a browser that supports WebGPU");return}else console.log("WebGPU is supported");I.lost.then((U)=>{if(console.error(`WebGPU device was lost: ${U.message}`),I=null,U.reason!=="destroyed")w()});var h=document.querySelector("canvas");const y=await fetch("./shaders/plife_compute.wgsl").then((U)=>U.text()),N=new Float32Array(D.K*D.K);for(let U=0;U<D.K;++U)for(let K=0;K<D.K;++K){let M=U==K?1:0,O=U==K+1?1:0;N[U+D.K*K]=M+0.1*(O%D.K)}const E=new Uint32Array(D.n),q=new Float32Array(D.n*3),z=new Float32Array(D.n*3);for(let U=0;U<D.n;U++)E[U]=U%D.m,q[3*U]=Math.random(),q[3*U+1]=Math.random(),q[3*U+2]=Math.random(),z[3*U]=0,z[3*U+1]=0,z[3*U+2]=0;const Q=I.createBuffer({label:"params buffer",size:Object.keys(D).length*4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),T=I.createBuffer({label:"F buffer",size:D.K*D.K*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),W=I.createBuffer({label:"colors buffer",size:D.n_agents*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),X=I.createBuffer({label:"velocities buffer",size:D.n_agents*3*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),H=I.createBuffer({label:"positions buffer",size:D.n_agents*3*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC}),A=I.createBuffer({label:"Position buffer result",size:D.n_agents*3*4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});I.queue.writeBuffer(H,0,q),I.queue.writeBuffer(X,0,z),I.queue.writeBuffer(W,0,E),I.queue.writeBuffer(T,0,N);function S(){I.queue.writeBuffer(Q,0,new Float32Array(Object.values(D)))}S();const Y=I.createShaderModule({label:"Particle Life Compute Shader",code:y}),J=I.createComputePipeline({label:"compute velocities pipeline",layout:"auto",compute:{module:Y,entryPoint:"update_velocities"}}),b=I.createComputePipeline({label:"update positions pipeline",layout:"auto",compute:{module:Y,entryPoint:"update_positions"}}),Z=I.createBindGroup({layout:J.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:W}},{binding:1,resource:{buffer:X}},{binding:2,resource:{buffer:H}},{binding:3,resource:{buffer:T}}]}),$=I.createBindGroup({layout:J.getBindGroupLayout(1),entries:[{binding:0,resource:{buffer:Q}}]});async function C(){const U=I.createCommandEncoder({label:"our command encoder"}),K=U.beginComputePass();K.setPipeline(J),K.setBindGroup(0,Z),K.setBindGroup(1,$),K.dispatchWorkgroups(D.n_agents/64),K.end();const M=U.beginComputePass();M.setPipeline(b),M.setBindGroup(0,Z),M.setBindGroup(1,$),M.dispatchWorkgroups(D.n_agents/64),M.end(),U.copyBufferToBuffer(H,0,A,0,A.size);const O=U.finish();I.queue.submit([O])}async function G(U,K=1){for(let k=0;k<K;++k)await C();await A.mapAsync(GPUMapMode.READ);const M=new Float32Array(A.getMappedRange()),{width:O,height:L}=U.canvas;U.resetTransform(),U.clearRect(0,0,O,L),U.lineWidth=0.1,U.fillStyle="black",U.fillRect(0,0,O,L);for(let k=0;k<n;++k){U.beginPath();const F=M[k*3]*O,R=M[k*3+1]*L;U.arc(F,R,6,0,Math.PI*2),U.fillStyle=`hsl(${E[k]*360/m}, 100%, 50%)`,U.fill(),U.stroke()}}function P(U){let K=window.devicePixelRatio||1,M=U.getBoundingClientRect();U.width=M.width*K,U.height=M.height*K;let O=U.getContext("2d");return O.scale(K,K),O}function g(){return P(document.querySelector("canvas"))}const j=g();while(!0)G(j),await new Promise(requestAnimationFrame)}w();
