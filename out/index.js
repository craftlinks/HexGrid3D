function g(q,C){return C.set(q),C}async function m(){const q=[16,16],C=1/Math.max(q[0],q[1]),w=await(await navigator.gpu?.requestAdapter())?.requestDevice();if(!w){fail("need a browser that supports WebGPU");return}else console.log("WebGPU is supported");const k=document.querySelector("canvas"),y=k.getContext("webgpu"),E=navigator.gpu.getPreferredCanvasFormat();y.configure({device:w,format:E});const J=await fetch("./shaders/hexgrid3d_vertex.wgsl").then((Y)=>Y.text()),b=await fetch("./shaders/hexgrid3d_fragment.wgsl").then((Y)=>Y.text()),_=w.createShaderModule({label:"HexGrid3D vertex shader",code:J}),D=w.createShaderModule({label:"HexGrid3D fragment shader",code:b}),T=8,c=16,S=16,W=4,X=q[0]*q[1]*T,Z=S,N=q[0]*q[1]*W,$=w.createBuffer({label:"Hex attributes storage buffer for objects",size:X,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),H=w.createBuffer({label:"global attributes uniform",size:Z,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),o=0,d=2;{const Y=new Float32Array(X/4);for(let j=0;j<q[0]*q[1];++j){const R=j*(T/4);let K=j%q[0],L=Math.floor(j/q[0]);L%2==1||(K+=0.5),Y.set([K*Math.sqrt(3)*C,L*3/2*C],R)}w.queue.writeBuffer($,0,Y)}const O=w.createBuffer({label:"state buffer 0",size:N,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),Q=new Int32Array(N/4),U=new Int32Array(N/4);for(let Y=0;Y<q[0]*q[1];++Y){const j=Y*(W/4);if(Y==q[0]*q[1]/2+q[0]/2)Q.set([12],j)}const{vertexData:F,numVertices:h}=u({hexSize:C,center:{x:-1-C,y:-1+C}}),P=w.createBuffer({label:"storage buffer vertices",size:F.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});w.queue.writeBuffer(P,0,F);const I=w.createRenderPipeline({label:"HexGrid3D pipeline",layout:"auto",vertex:{module:_,entryPoint:"vs"},fragment:{module:D,entryPoint:"fs",targets:[{format:E}]}}),l=w.createBindGroup({label:"flip bind group for objects",layout:I.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:$}},{binding:1,resource:{buffer:O}},{binding:2,resource:{buffer:H}},{binding:3,resource:{buffer:P}}]}),V={label:"our basic canvas renderPass",colorAttachments:[{clearValue:[0,0,0,1],loadOp:"clear",storeOp:"store"}]},A=new Float32Array(Z/4);function p(Y){var j=Y;k.width=Math.max(1,w.limits.maxTextureDimension2D),k.height=Math.max(1,w.limits.maxTextureDimension2D);const R=j==1?Q:U,K=j==1?U:Q,L=g(R,K);V.colorAttachments[0].view=y.getCurrentTexture().createView();const B=w.createCommandEncoder({label:"our simulation renderer encoder"}),M=B.beginRenderPass(V);M.setPipeline(I);const v=k.width/k.height,z=1;A.set([z/v,z,q[0],q[1]],0),w.queue.writeBuffer(H,0,A),w.queue.writeBuffer(O,0,L),M.setBindGroup(0,l),M.draw(h,q[0]*q[1]),M.end();const f=B.finish();w.queue.submit([f]),j=1-j,setTimeout(()=>{p(j)},500)}p(1)}var u=function({hexSize:q=0.1,center:C={x:0,y:0}}={}){const w=new Float32Array(36),k=new Float32Array(12);for(let y=0;y<6;y++){const E=y*2,J=2*Math.PI*((y+0.5)/6);k[E]=q*Math.cos(J),k[E+1]=q*Math.sin(J)}for(let y=0;y<6;y++){const E=y*6,J=y*2;w[E+0]=C.x,w[E+1]=C.y,w[E+2]=C.x+k[J],w[E+3]=C.y+k[J+1],w[E+4]=C.x+k[(J+2)%12],w[E+5]=C.y+k[(J+3)%12]}return{vertexData:w,numVertices:18}};m();