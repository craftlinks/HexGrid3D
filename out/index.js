async function c(){const E=[512,512],C=1/Math.max(E[0],E[1]),w=await(await navigator.gpu?.requestAdapter())?.requestDevice();if(!w){fail("need a browser that supports WebGPU");return}else console.log("WebGPU is supported");const k=document.querySelector("canvas"),F=k.getContext("webgpu"),y=navigator.gpu.getPreferredCanvasFormat();F.configure({device:w,format:y});const _=await fetch("./shaders/hexgrid3d_vertex.wgsl").then((j)=>j.text()),b=await fetch("./shaders/hexgrid3d_fragment.wgsl").then((j)=>j.text()),B=await fetch("./shaders/hexgrid3d_compute.wgsl").then((j)=>j.text()),D=w.createShaderModule({label:"HexGrid3D vertex shader",code:_}),S=w.createShaderModule({label:"HexGrid3D fragment shader",code:b}),h=w.createShaderModule({label:"HexGrid3D compute module",code:B}),H=8,O=16,p=16,U=E[0]*E[1]*H,T=E[0]*E[1]*O,I=p,W=w.createBuffer({label:"Hex attributes storage buffer for objects",size:U,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),R=w.createBuffer({label:"flip colors storage buffer for objects",size:T,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),X=w.createBuffer({label:"flop colors storage buffer for objects",size:T,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),Q=w.createBuffer({label:"global attributes uniform",size:I,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),o=0,s=2;{const j=new Float32Array(U/4);for(let q=0;q<E[0]*E[1];++q){const K=q*(H/4);let L=q%E[0],N=Math.floor(q/E[0]);N%2==1||(L+=0.5),j.set([L*Math.sqrt(3)*C,N*3/2*C],K)}w.queue.writeBuffer(W,0,j)}{const j=new Float32Array(T/4);for(let q=0;q<E[0]*E[1];++q){const K=q*(O/4);if(j.set([0,0,0,1],K),q==E[0]*E[1]/2+E[0]/2)j.set([1,0,0,1],K)}w.queue.writeBuffer(R,0,j)}const{vertexData:V,numVertices:v}=x({hexSize:C,center:{x:-1-C,y:-1+C}}),Y=w.createBuffer({label:"storage buffer vertices",size:V.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});w.queue.writeBuffer(Y,0,V);const Z=w.createComputePipeline({label:"compute pipeline",layout:"auto",compute:{module:h,entryPoint:"main"}}),$=w.createRenderPipeline({label:"HexGrid3D pipeline",layout:"auto",vertex:{module:D,entryPoint:"vs"},fragment:{module:S,entryPoint:"fs",targets:[{format:y}]}}),l=w.createBindGroup({label:"flip bind group for objects",layout:$.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:W}},{binding:1,resource:{buffer:R}},{binding:2,resource:{buffer:Q}},{binding:3,resource:{buffer:Y}}]}),f=w.createBindGroup({label:"flop bind group for objects",layout:$.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:W}},{binding:1,resource:{buffer:X}},{binding:2,resource:{buffer:Q}},{binding:3,resource:{buffer:Y}}]}),u=w.createBindGroup({layout:Z.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:Q}},{binding:1,resource:{buffer:R}},{binding:2,resource:{buffer:X}}]}),m=w.createBindGroup({layout:Z.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:Q}},{binding:1,resource:{buffer:X}},{binding:2,resource:{buffer:R}}]}),P={label:"our basic canvas renderPass",colorAttachments:[{clearValue:[0,0,0,1],loadOp:"clear",storeOp:"store"}]},A=new Float32Array(I/4);function z(j){var q=j;k.width=Math.max(1,w.limits.maxTextureDimension2D),k.height=Math.max(1,w.limits.maxTextureDimension2D),console.log(`loop_start: ${j}`),P.colorAttachments[0].view=F.getCurrentTexture().createView();const K=w.createCommandEncoder({label:"our first triangle encoder"}),L=K.beginComputePass();L.setPipeline(Z),L.setBindGroup(0,j?u:m),L.dispatchWorkgroups(E[0],E[1]),L.end();const N=K.beginRenderPass(P);N.setPipeline($);const d=k.width/k.height,G=1;A.set([G/d,G,E[0],E[1]],0),w.queue.writeBuffer(Q,0,A),N.setBindGroup(0,j?l:f),N.draw(v,E[0]*E[1]),N.end();const a=K.finish();w.queue.submit([a]),q=1-q,setTimeout(()=>{z(q)},100)}z(1)}var x=function({hexSize:E=0.1,center:C={x:0,y:0}}={}){const J=new Float32Array(36),M=new Float32Array(12);for(let w=0;w<6;w++){const k=w*2,F=2*Math.PI*((w+0.5)/6);M[k]=E*Math.cos(F),M[k+1]=E*Math.sin(F)}for(let w=0;w<6;w++){const k=w*6,F=w*2;J[k+0]=C.x,J[k+1]=C.y,J[k+2]=C.x+M[F],J[k+3]=C.y+M[F+1],J[k+4]=C.x+M[(F+2)%12],J[k+5]=C.y+M[(F+3)%12]}return console.log(J),{vertexData:J,numVertices:18}};c();