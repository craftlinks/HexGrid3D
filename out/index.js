async function c(){const T=[1024,1024],q=1/Math.max(T[0],T[1]),w=await(await navigator.gpu?.requestAdapter())?.requestDevice();if(!w){fail("need a browser that supports WebGPU");return}else console.log("WebGPU is supported");const M=document.querySelector("canvas"),k=M.getContext("webgpu"),H=navigator.gpu.getPreferredCanvasFormat();k.configure({device:w,format:H});const B=await fetch("./shaders/hexgrid3d_vertex.wgsl").then((E)=>E.text()),b=await fetch("./shaders/hexgrid3d_fragment.wgsl").then((E)=>E.text()),D=await fetch("./shaders/hexgrid3d_compute.wgsl").then((E)=>E.text()),S=w.createShaderModule({label:"HexGrid3D vertex shader",code:B}),h=w.createShaderModule({label:"HexGrid3D fragment shader",code:b}),p=w.createShaderModule({label:"HexGrid3D compute module",code:D}),U=8,O=16,v=16,I=T[0]*T[1]*U,W=T[0]*T[1]*O,P=v,X=w.createBuffer({label:"Hex attributes storage buffer for objects",size:I,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),R=w.createBuffer({label:"flip colors storage buffer for objects",size:W,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),Y=w.createBuffer({label:"flop colors storage buffer for objects",size:W,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),Q=w.createBuffer({label:"global attributes uniform",size:P,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),s=0,t=2;{const E=new Float32Array(I/4);for(let j=0;j<T[0]*T[1];++j){const K=j*(U/4);let J=j%T[0],L=Math.floor(j/T[0]);L%2==1||(J+=0.5),E.set([J*Math.sqrt(3)*q,L*3/2*q],K)}w.queue.writeBuffer(X,0,E)}{const E=new Float32Array(W/4);for(let j=0;j<T[0]*T[1];++j){const K=j*(O/4);E.set([0,0,0,1],K);let J=Math.floor(j/T[0]),L=j%T[0];if(F(1)>0.99)E.set([1,F(1),F(0.75),1],K)}w.queue.writeBuffer(R,0,E)}const{vertexData:V,numVertices:f}=o({hexSize:q,center:{x:-1-q,y:-1+q}}),Z=w.createBuffer({label:"storage buffer vertices",size:V.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});w.queue.writeBuffer(Z,0,V);const $=w.createComputePipeline({label:"compute pipeline",layout:"auto",compute:{module:p,entryPoint:"main"}}),y=w.createRenderPipeline({label:"HexGrid3D pipeline",layout:"auto",vertex:{module:S,entryPoint:"vs"},fragment:{module:h,entryPoint:"fs",targets:[{format:H}]}}),l=w.createBindGroup({label:"flip bind group for objects",layout:y.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:X}},{binding:1,resource:{buffer:R}},{binding:2,resource:{buffer:Q}},{binding:3,resource:{buffer:Z}}]}),m=w.createBindGroup({label:"flop bind group for objects",layout:y.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:X}},{binding:1,resource:{buffer:Y}},{binding:2,resource:{buffer:Q}},{binding:3,resource:{buffer:Z}}]}),u=w.createBindGroup({layout:$.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:Q}},{binding:1,resource:{buffer:R}},{binding:2,resource:{buffer:Y}}]}),d=w.createBindGroup({layout:$.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:Q}},{binding:1,resource:{buffer:Y}},{binding:2,resource:{buffer:R}}]}),A={label:"our basic canvas renderPass",colorAttachments:[{clearValue:[0,0,0,1],loadOp:"clear",storeOp:"store"}]},z=new Float32Array(P/4);function g(E){var j=E;M.width=Math.max(1,w.limits.maxTextureDimension2D),M.height=Math.max(1,w.limits.maxTextureDimension2D),A.colorAttachments[0].view=k.getCurrentTexture().createView();const K=w.createCommandEncoder({label:"our first triangle encoder"}),J=K.beginComputePass();J.setPipeline($),J.setBindGroup(0,E?u:d),J.dispatchWorkgroups(T[0]/4,T[1]/4),J.end();const L=K.beginRenderPass(A);L.setPipeline(y);const x=M.width/M.height,G=1;z.set([G/x,G,T[0],T[1]],0),w.queue.writeBuffer(Q,0,z),L.setBindGroup(0,E?l:m),L.draw(f,T[0]*T[1]),L.end();const a=K.finish();w.queue.submit([a]),j=1-j,setTimeout(()=>{g(j)},100)}g(1)}var o=function({hexSize:T=0.1,center:q={x:0,y:0}}={}){const C=new Float32Array(36),N=new Float32Array(12);for(let w=0;w<6;w++){const M=w*2,k=2*Math.PI*((w+0.5)/6);N[M]=T*Math.cos(k),N[M+1]=T*Math.sin(k)}for(let w=0;w<6;w++){const M=w*6,k=w*2;C[M+0]=q.x,C[M+1]=q.y,C[M+2]=q.x+N[k],C[M+3]=q.y+N[k+1],C[M+4]=q.x+N[(k+2)%12],C[M+5]=q.y+N[(k+3)%12]}return console.log(C),{vertexData:C,numVertices:18}};c();var F=(T,q)=>{if(T===void 0)T=0,q=1;else if(q===void 0)q=T,T=0;return T+Math.random()*(q-T)};
