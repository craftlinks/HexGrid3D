async function w(){const A=await(await navigator.gpu?.requestAdapter())?.requestDevice();if(!A){fail("need a browser that supports WebGPU");return}else console.log("WebGPU is supported");var I=document.querySelector("canvas");const H=await fetch("./shaders/lenia_compute.wgsl").then((W)=>W.text()),O=A.createBuffer({size:Object.keys(b).length*4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),U=A.createBuffer({label:"Rval buffer",size:b.point_n*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),V=A.createBuffer({label:"Uval buffer",size:b.point_n*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),X=A.createBuffer({label:"Rgrad buffer",size:b.point_n*2*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),Y=A.createBuffer({label:"Ugrad buffer",size:b.point_n*2*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),J=A.createBuffer({label:"Position buffer",size:b.point_n*2*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}),y=A.createBuffer({label:"Position buffer result",size:b.point_n*2*4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});{const W=new Float32Array(b.point_n*2);for(let D=0;D<b.point_n;++D)W[D*2]=(Math.random()-0.5)*48,W[D*2+1]=(Math.random()-0.5)*48;A.queue.writeBuffer(J,0,W)}A.queue.writeBuffer(O,0,new Float32Array(Object.values(b)));const K=A.createShaderModule({label:"Lenia Compute Shader",code:H}),Z=A.createComputePipeline({label:"reset pipeline",layout:"auto",compute:{module:K,entryPoint:"reset_buffers"}}),L=A.createComputePipeline({label:"compute fields pipeline",layout:"auto",compute:{module:K,entryPoint:"compute_fields"}}),$=A.createComputePipeline({label:"update positions pipeline",layout:"auto",compute:{module:K,entryPoint:"update_positions"}}),M=A.createBindGroup({layout:L.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:U}},{binding:1,resource:{buffer:V}},{binding:2,resource:{buffer:X}},{binding:3,resource:{buffer:Y}},{binding:4,resource:{buffer:J}}]}),N=A.createBindGroup({layout:L.getBindGroupLayout(1),entries:[{binding:0,resource:{buffer:O}}]});async function C(){const W=A.createCommandEncoder({label:"our command encoder"}),D=W.beginComputePass();D.setPipeline(Z),D.setBindGroup(0,M),D.setBindGroup(1,N),D.dispatchWorkgroups(b.point_n/64),D.end();const j=W.beginComputePass();j.setPipeline(L),j.setBindGroup(0,M),j.setBindGroup(1,N),j.dispatchWorkgroups(b.point_n/64),j.end();const E=W.beginComputePass();E.setPipeline($),E.setBindGroup(0,M),E.setBindGroup(1,N),E.dispatchWorkgroups(b.point_n/64),E.end(),W.copyBufferToBuffer(J,0,y,0,y.size);const z=W.finish();A.queue.submit([z])}async function S(W,D=100,j=5){for(let k=0;k<j;++k)await C();await y.mapAsync(GPUMapMode.READ);const E=new Float32Array(y.getMappedRange()),{width:z,height:Q}=W.canvas;W.resetTransform(),W.clearRect(0,0,z,Q),W.translate(z/2,Q/2);const T=z/D;W.scale(T,T),W.lineWidth=0.05;for(let k=0;k<b.point_n;++k){W.beginPath();const F=E[k*2],G=E[k*2+1];W.arc(F,G,0.075,0,Math.PI*2),W.stroke()}y.unmap()}const g=h();while(!0)await S(g),await new Promise(requestAnimationFrame)}var R=function(q){let A=window.devicePixelRatio||1,I=q.getBoundingClientRect();q.width=I.width*A,q.height=I.height*A;let H=q.getContext("2d");return H.scale(A,A),H},h=function(){return R(document.querySelector("canvas"))},b={mu_k:4,sigma_k:1,w_k:0.022,mu_g:0.6,sigma_g:0.15,c_rep:1,dt:0.02,point_n:3200};w();
