async function c(){const E=[512,512],q=1/Math.max(E[0],E[1]),w=await(await navigator.gpu?.requestAdapter())?.requestDevice();if(!w){fail("need a browser that supports WebGPU");return}else console.log("WebGPU is supported");const j=document.querySelector("canvas"),C=j.getContext("webgpu"),F=navigator.gpu.getPreferredCanvasFormat();C.configure({device:w,format:F});const g=await fetch("./shaders/hexgrid3d_vertex.wgsl").then((T)=>T.text()),b=await fetch("./shaders/hexgrid3d_fragment.wgsl").then((T)=>T.text()),B=await fetch("./shaders/hexgrid3d_compute.wgsl").then((T)=>T.text()),S=w.createShaderModule({label:"HexGrid3D vertex shader",code:g}),D=w.createShaderModule({label:"HexGrid3D fragment shader",code:b}),h=w.createShaderModule({label:"HexGrid3D compute module",code:B}),H=8,O=16,p=16,U=E[0]*E[1]*H,W=E[0]*E[1]*O,I=p,X=w.createBuffer({label:"Hex attributes storage buffer for objects",size:U,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),R=w.createBuffer({label:"flip colors storage buffer for objects",size:W,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),Y=w.createBuffer({label:"flop colors storage buffer for objects",size:W,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),Q=w.createBuffer({label:"global attributes uniform",size:I,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),o=0,s=2;{const T=new Float32Array(U/4);for(let k=0;k<E[0]*E[1];++k){const K=k*(H/4);let L=k%E[0],N=Math.floor(k/E[0]);N%2==1||(L+=0.5),T.set([L*Math.sqrt(3)*q,N*3/2*q],K)}w.queue.writeBuffer(X,0,T)}{const T=new Float32Array(W/4);for(let k=0;k<E[0]*E[1];++k){const K=k*(O/4);if(T.set([0,0,0,1],K),k==E[0]*E[1]/2+E[0]/2)T.set([1,0,0,1],K)}w.queue.writeBuffer(R,0,T)}const{vertexData:P,numVertices:v}=x({hexSize:q,center:{x:-1-q,y:-1+q}}),Z=w.createBuffer({label:"storage buffer vertices",size:P.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});w.queue.writeBuffer(Z,0,P);const $=w.createComputePipeline({label:"compute pipeline",layout:"auto",compute:{module:h,entryPoint:"main"}}),y=w.createRenderPipeline({label:"HexGrid3D pipeline",layout:"auto",vertex:{module:S,entryPoint:"vs"},fragment:{module:D,entryPoint:"fs",targets:[{format:F}]}}),l=w.createBindGroup({label:"flip bind group for objects",layout:y.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:X}},{binding:1,resource:{buffer:R}},{binding:2,resource:{buffer:Q}},{binding:3,resource:{buffer:Z}}]}),f=w.createBindGroup({label:"flop bind group for objects",layout:y.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:X}},{binding:1,resource:{buffer:Y}},{binding:2,resource:{buffer:Q}},{binding:3,resource:{buffer:Z}}]}),u=w.createBindGroup({layout:$.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:Q}},{binding:1,resource:{buffer:R}},{binding:2,resource:{buffer:Y}}]}),m=w.createBindGroup({layout:$.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:Q}},{binding:1,resource:{buffer:Y}},{binding:2,resource:{buffer:R}}]}),V={label:"our basic canvas renderPass",colorAttachments:[{clearValue:[0,0,0,1],loadOp:"clear",storeOp:"store"}]},A=new Float32Array(I/4);function z(T){var k=T;j.width=Math.max(1,w.limits.maxTextureDimension2D),j.height=Math.max(1,w.limits.maxTextureDimension2D),console.log(`loop_start: ${T}`),V.colorAttachments[0].view=C.getCurrentTexture().createView();const K=w.createCommandEncoder({label:"our first triangle encoder"}),L=K.beginComputePass();L.setPipeline($),L.setBindGroup(0,T?u:m),L.dispatchWorkgroups(E[0]/4,E[1]/4),L.end();const N=K.beginRenderPass(V);N.setPipeline(y);const d=j.width/j.height,G=1;A.set([G/d,G,E[0],E[1]],0),w.queue.writeBuffer(Q,0,A),N.setBindGroup(0,T?l:f),N.draw(v,E[0]*E[1]),N.end();const a=K.finish();w.queue.submit([a]),k=1-k,setTimeout(()=>{z(k)},10)}z(1)}var x=function({hexSize:E=0.1,center:q={x:0,y:0}}={}){const J=new Float32Array(36),M=new Float32Array(12);for(let w=0;w<6;w++){const j=w*2,C=2*Math.PI*((w+0.5)/6);M[j]=E*Math.cos(C),M[j+1]=E*Math.sin(C)}for(let w=0;w<6;w++){const j=w*6,C=w*2;J[j+0]=q.x,J[j+1]=q.y,J[j+2]=q.x+M[C],J[j+3]=q.y+M[C+1],J[j+4]=q.x+M[(C+2)%12],J[j+5]=q.y+M[(C+3)%12]}return console.log(J),{vertexData:J,numVertices:18}};c();