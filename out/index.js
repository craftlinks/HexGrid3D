async function a(){const k=[150,150],q=1/Math.max(k[0],k[1]),C=await(await navigator.gpu?.requestAdapter())?.requestDevice();if(!C){fail("need a browser that supports WebGPU");return}else console.log("WebGPU is supported");const L=document.querySelector("canvas"),j=L.getContext("webgpu"),y=navigator.gpu.getPreferredCanvasFormat();j.configure({device:C,format:y});const _=await fetch("./shaders/hexgrid3d_vertex.wgsl").then((J)=>J.text()),B=await fetch("./shaders/hexgrid3d_fragment.wgsl").then((J)=>J.text()),D=await fetch("./shaders/hexgrid3d_compute.wgsl").then((J)=>J.text()),S=C.createShaderModule({label:"HexGrid3D vertex shader",code:_}),p=C.createShaderModule({label:"HexGrid3D fragment shader",code:B}),h=C.createShaderModule({label:"HexGrid3D compute module",code:D}),O=8,U=16,v=16,I=k[0]*k[1]*O,W=k[0]*k[1]*U,P=v,X=C.createBuffer({label:"Hex attributes storage buffer for objects",size:I,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),R=C.createBuffer({label:"flip colors storage buffer for objects",size:W,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),Y=C.createBuffer({label:"flop colors storage buffer for objects",size:W,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),Q=C.createBuffer({label:"global attributes uniform",size:P,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),s=0,n=2;{const J=new Float32Array(I/4);for(let M=0;M<k[0]*k[1];++M){const H=M*(O/4);let E=M%k[0],K=Math.floor(M/k[0]);K%2==1||(E+=0.5),J.set([E*Math.sqrt(3)*q,K*3/2*q],H)}C.queue.writeBuffer(X,0,J)}{const J=new Float32Array(W/4);for(let M=0;M<k[0]*k[1];++M){const H=M*(U/4);J.set([0,0,0,1],H);let E=Math.floor(M/k[0]),K=M%k[0];if(T(1)>0.999)J.set([T(0.5),T(0.5),T(0.5),1],H)}C.queue.writeBuffer(R,0,J)}const{vertexData:V,numVertices:l}=o({hexSize:q,center:{x:-1-q,y:-1+q}}),Z=C.createBuffer({label:"storage buffer vertices",size:V.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});C.queue.writeBuffer(Z,0,V);const $=C.createComputePipeline({label:"compute pipeline",layout:"auto",compute:{module:h,entryPoint:"main"}}),F=C.createRenderPipeline({label:"HexGrid3D pipeline",layout:"auto",vertex:{module:S,entryPoint:"vs"},fragment:{module:p,entryPoint:"fs",targets:[{format:y}]}}),f=C.createBindGroup({label:"flip bind group for objects",layout:F.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:X}},{binding:1,resource:{buffer:R}},{binding:2,resource:{buffer:Q}},{binding:3,resource:{buffer:Z}}]}),m=C.createBindGroup({label:"flop bind group for objects",layout:F.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:X}},{binding:1,resource:{buffer:Y}},{binding:2,resource:{buffer:Q}},{binding:3,resource:{buffer:Z}}]}),u=C.createBindGroup({layout:$.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:Q}},{binding:1,resource:{buffer:R}},{binding:2,resource:{buffer:Y}}]}),x=C.createBindGroup({layout:$.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:Q}},{binding:1,resource:{buffer:Y}},{binding:2,resource:{buffer:R}}]}),A={label:"our basic canvas renderPass",colorAttachments:[{clearValue:[0,0,0,1],loadOp:"clear",storeOp:"store"}]},z=new Float32Array(P/4);function b(J){var M=J;L.width=Math.max(1,C.limits.maxTextureDimension2D),L.height=Math.max(1,C.limits.maxTextureDimension2D),A.colorAttachments[0].view=j.getCurrentTexture().createView();const H=C.createCommandEncoder({label:"our first triangle encoder"}),E=H.beginComputePass();E.setPipeline($),E.setBindGroup(0,J?u:x),E.dispatchWorkgroups(k[0]/4,k[1]/4),E.end();const K=H.beginRenderPass(A);K.setPipeline(F);const d=L.width/L.height,g=1;z.set([g/d,g,k[0],k[1]],0),C.queue.writeBuffer(Q,0,z),K.setBindGroup(0,J?f:m),K.draw(l,k[0]*k[1]),K.end();const c=H.finish();C.queue.submit([c]),M=1-M,setTimeout(()=>{b(M)},50)}b(1)}var o=function({hexSize:k=0.1,center:q={x:0,y:0}}={}){const w=new Float32Array(36),N=new Float32Array(12);for(let C=0;C<6;C++){const L=C*2,j=2*Math.PI*((C+0.5)/6);N[L]=k*Math.cos(j),N[L+1]=k*Math.sin(j)}for(let C=0;C<6;C++){const L=C*6,j=C*2;w[L+0]=q.x,w[L+1]=q.y,w[L+2]=q.x+N[j],w[L+3]=q.y+N[j+1],w[L+4]=q.x+N[(j+2)%12],w[L+5]=q.y+N[(j+3)%12]}return console.log(w),{vertexData:w,numVertices:18}};a();var T=(k,q)=>{if(k===void 0)k=0,q=1;else if(q===void 0)q=k,k=0;return k+Math.random()*(q-k)};
