function d(q,Y,C){for(var R=0;R<C[1];R=R+1)for(var T=0;T<C[0];T=T+1){let Q=q[$(T,R)],J=U(T,R,q);if(J.fill(0),Q>0)J[0]=1e4}for(var E=0;E<2;E+=1){for(var R=0;R<C[1];R=R+1)for(var T=0;T<C[0];T=T+1)v(T,R,1,E);for(var R=0;R<C[1];R=R+1)for(var T=0;T<C[0];T=T+1){var V=U(T,R,Y);if(V[E]<80)V[E]=0;if(V[E+1]<80)V[E+1]=0}}for(var R=0;R<C[1];R=R+1)for(var T=0;T<C[0];T=T+1){var B=0,I=0;for(var E=0;E<0;E+=1)B+=U(T,R,Y)[E];for(var E=1;E<2;E+=1)I+=U(T,R,Y)[E];if(I=I+B,B>I*0.6)Y[$(T,R)]=1;if(B<I*0.6)Y[$(T,R)]=0;if(B==I*0.6){if(q[$(T,R)]==0)Y[$(T,R)]=0;if(q[$(T,R)]==1)Y[$(T,R)]=1}}function U(Q,J,P){return P.subarray($(Q,J)+1,$(Q,J)+2+1)}function $(Q,J){let P=(Q+C[0])%C[0];return(J+C[1])%C[1]*(C[0]*3)+P*3}function v(Q,J,P,K){var j=U(Q,J,q);if(j[K]==0)return;let z=Q,w=J;for(var H=0;H<P;H=H+1){let k=u(J);z=z-k,w=w-1}var W=[z,w];let g=j[K];for(var H=0;H<6;H=H+1)for(var S=0;S<P;S=S+1){if(j[K]<=0)break;j[K]-=Math.round(g*0.95/7);var A=U(W[0],W[1],Y);A[K+1]+=Math.round(g*0.95/7),W=c(W[0],W[1],a[H])}j[K]-=g*0.05,A[K]+=g*0.05;while(j[K]>0){let k=Math.floor(Math.random()*7);if(j[K]-=1,k<=5)W=c(W[0],W[1],a[k]),A=U(W[0],W[1],Y),A[K+1]+=1;else A[K]+=1}}return q}var c=function(q,Y,C){let L=u(Y);if(C[1]==0)return[q+C[0],Y];else return[q+C[0]-L,Y+C[1]]},u=function(q){return q&1},a=[[1,0],[1,1],[0,1],[-1,0],[0,-1],[1,-1]];async function s(){const q=[64,64],Y=1/Math.max(q[0],q[1]),L=await(await navigator.gpu?.requestAdapter())?.requestDevice();if(!L){fail("need a browser that supports WebGPU");return}else console.log("WebGPU is supported");const M=document.querySelector("canvas"),N=M.getContext("webgpu"),O=navigator.gpu.getPreferredCanvasFormat();N.configure({device:L,format:O});const F=await fetch("./shaders/hexgrid3d_vertex.wgsl").then((X)=>X.text()),R=await fetch("./shaders/hexgrid3d_fragment.wgsl").then((X)=>X.text()),T=L.createShaderModule({label:"HexGrid3D vertex shader",code:F}),E=L.createShaderModule({label:"HexGrid3D fragment shader",code:R}),V=8,B=16,I=16,U=12,$=q[0]*q[1]*V,v=I,Q=q[0]*q[1]*U,J=L.createBuffer({label:"Hex attributes storage buffer for objects",size:$,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),P=L.createBuffer({label:"global attributes uniform",size:v,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),K=0,j=2;{const X=new Float32Array($/4);for(let Z=0;Z<q[0]*q[1];++Z){const l=Z*(V/4);let p=Z%q[0],G=Math.floor(Z/q[0]);G%2==1||(p+=0.5),X.set([p*Math.sqrt(3)*Y,G*3/2*Y],l)}L.queue.writeBuffer(J,0,X)}const z=L.createBuffer({label:"state buffer 0",size:Q,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),w=new Int32Array(Q/4),H=new Int32Array(Q/4);for(let X=0;X<q[0]*q[1];++X){const Z=X*(U/4);if(X==q[0]*q[1]/2+q[0]/2)w.set([1,0],Z),H.set(w)}const{vertexData:W,numVertices:g}=_({hexSize:Y,center:{x:-1-Y,y:-1+Y}}),S=L.createBuffer({label:"storage buffer vertices",size:W.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});L.queue.writeBuffer(S,0,W);const A=L.createRenderPipeline({label:"HexGrid3D pipeline",layout:"auto",vertex:{module:T,entryPoint:"vs"},fragment:{module:E,entryPoint:"fs",targets:[{format:O}]}}),k=L.createBindGroup({label:"flip bind group for objects",layout:A.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:J}},{binding:1,resource:{buffer:z}},{binding:2,resource:{buffer:P}},{binding:3,resource:{buffer:S}}]}),D={label:"our basic canvas renderPass",colorAttachments:[{clearValue:[0,0,0,1],loadOp:"clear",storeOp:"store"}]},h=new Float32Array(v/4);function m(X){var Z=X;M.width=Math.max(1,L.limits.maxTextureDimension2D),M.height=Math.max(1,L.limits.maxTextureDimension2D);const l=Z==1?w:H,p=Z==1?H:w,G=d(l,p,q);D.colorAttachments[0].view=N.getCurrentTexture().createView();const f=L.createCommandEncoder({label:"our simulation renderer encoder"}),y=f.beginRenderPass(D);y.setPipeline(A);const o=M.width/M.height,b=1;h.set([b/o,b,q[0],q[1]],0),L.queue.writeBuffer(P,0,h),L.queue.writeBuffer(z,0,G),y.setBindGroup(0,k),y.draw(g,q[0]*q[1]),y.end();const x=f.finish();L.queue.submit([x]),Z=1-Z,setTimeout(()=>{m(Z)},1000)}m(1)}var _=function({hexSize:q=0.1,center:Y={x:0,y:0}}={}){const L=new Float32Array(36),M=new Float32Array(12);for(let N=0;N<6;N++){const O=N*2,F=2*Math.PI*((N+0.5)/6);M[O]=q*Math.cos(F),M[O+1]=q*Math.sin(F)}for(let N=0;N<6;N++){const O=N*6,F=N*2;L[O+0]=Y.x,L[O+1]=Y.y,L[O+2]=Y.x+M[F],L[O+3]=Y.y+M[F+1],L[O+4]=Y.x+M[(F+2)%12],L[O+5]=Y.y+M[(F+3)%12]}return{vertexData:L,numVertices:18}};s();