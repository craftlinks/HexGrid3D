async function v(){const q=[10,10],E=1/Math.max(q[0],q[1]),w=await(await navigator.gpu?.requestAdapter())?.requestDevice();if(!w){fail("need a browser that supports WebGPU");return}else console.log("WebGPU is supported");const C=document.querySelector("canvas"),J=C.getContext("webgpu"),T=navigator.gpu.getPreferredCanvasFormat();J.configure({device:w,format:T});const z=await fetch("./shaders/hexgrid3d_vertex.wgsl").then((k)=>k.text()),B=await fetch("./shaders/hexgrid3d_fragment.wgsl").then((k)=>k.text()),G=await fetch("./shaders/hexgrid3d_compute.wgsl").then((k)=>k.text()),g=w.createShaderModule({label:"HexGrid3D vertex shader",code:z}),b=w.createShaderModule({label:"HexGrid3D fragment shader",code:B}),S=w.createShaderModule({label:"HexGrid3D compute module",code:G}),W=8,X=16,p=16,Y=q[0]*q[1]*W,Z=q[0]*q[1]*X,$=p,H=w.createBuffer({label:"Hex attributes storage buffer for objects",size:Y,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),Q=w.createBuffer({label:"colors storage buffer for objects",size:Z,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),R=w.createBuffer({label:"global attributes uniform",size:$,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),m=0,d=2;{const k=new Float32Array(Y/4);for(let j=0;j<q[0]*q[1];++j){const F=j*(W/4);let M=j%q[0],N=Math.floor(j/q[0]);N%2==1||(M+=0.5),k.set([M*Math.sqrt(3)*E,N*3/2*E],F)}w.queue.writeBuffer(H,0,k)}{const k=new Float32Array(Z/4);for(let j=0;j<q[0]*q[1];++j){const F=j*(X/4);if(k.set([0,0,0,1],F),j==55)k.set([1,0,0,1],F)}w.queue.writeBuffer(Q,0,k)}const{vertexData:O,numVertices:D}=u({hexSize:E,center:{x:-1-E,y:-1+E}}),U=w.createBuffer({label:"storage buffer vertices",size:O.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});w.queue.writeBuffer(U,0,O);const y=w.createComputePipeline({label:"compute pipeline",layout:"auto",compute:{module:S,entryPoint:"main"}}),I=w.createRenderPipeline({label:"HexGrid3D pipeline",layout:"auto",vertex:{module:g,entryPoint:"vs"},fragment:{module:b,entryPoint:"fs",targets:[{format:T}]}}),l=w.createBindGroup({label:"bind group for objects",layout:I.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:H}},{binding:1,resource:{buffer:Q}},{binding:2,resource:{buffer:R}},{binding:3,resource:{buffer:U}}]}),h=w.createBindGroup({layout:y.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:R}},{binding:1,resource:{buffer:Q}}]}),P={label:"our basic canvas renderPass",colorAttachments:[{clearValue:[0,0,0,1],loadOp:"clear",storeOp:"store"}]},V=new Float32Array($/4);function _(){P.colorAttachments[0].view=J.getCurrentTexture().createView();const k=w.createCommandEncoder({label:"our first triangle encoder"}),j=k.beginComputePass();j.setPipeline(y),j.setBindGroup(0,h),j.dispatchWorkgroups(q[0]*q[1]),j.end();const F=k.beginRenderPass(P);F.setPipeline(I);const M=C.width/C.height,N=1;V.set([N/M,N,q[0],q[1]],0),w.queue.writeBuffer(R,0,V),F.setBindGroup(0,l),F.draw(D,q[0]*q[1]),F.end();const f=k.finish();w.queue.submit([f])}_(),new ResizeObserver((k)=>{for(let j of k){const F=j.target,M=j.contentBoxSize[0].inlineSize,N=j.contentBoxSize[0].blockSize;F.width=Math.max(1,Math.min(M,w.limits.maxTextureDimension2D)),F.height=Math.max(1,Math.min(N,w.limits.maxTextureDimension2D)),_()}}).observe(C)}var u=function({hexSize:q=0.1,center:E={x:0,y:0}}={}){const K=new Float32Array(36),L=new Float32Array(12);for(let w=0;w<6;w++){const C=w*2,J=2*Math.PI*((w+0.5)/6);L[C]=q*Math.cos(J),L[C+1]=q*Math.sin(J)}for(let w=0;w<6;w++){const C=w*6,J=w*2;K[C+0]=E.x,K[C+1]=E.y,K[C+2]=E.x+L[J],K[C+3]=E.y+L[J+1],K[C+4]=E.x+L[(J+2)%12],K[C+5]=E.y+L[(J+3)%12]}return console.log(K),{vertexData:K,numVertices:18}};v();