function m(q,T,w){for(var M=0;M<w[1];M=M+1)for(var N=0;N<w[0];N=N+1){let Y=q[X(N,M)],Z=q.subarray(X(N,M)+1,X(N,M)+1+1)[0];if(Y>0)console.log("BEFORE:","c: ",Y,"t: ",Z),q.subarray(X(N,M)+1,X(N,M)+1+1)[0]=1e4,console.log("AFTER:","c: ",Y,"t: ",q[X(N,M)+1])}T.set(q);function X(Y,Z){let $=(Y+w[0])%w[0];return(Z+w[1])%w[1]*(w[0]*2)+$*2}function p(Y,Z,$,H){if(H==0)return;let O=Y,F=Z;for(var Q=0;Q<$;Q=Q+1){let j=_(Z);O=O-j,F=F-1}var k=H,P=[O,F];for(var Q=0;Q<6;Q=Q+1)for(var I=0;I<$;I=I+1){if(k<=0)break;T[X(P[0],P[1])]+=1,T[X(Y,Z)]-=1,k=k-1,P=d(P[0],P[1],a[Q])}}return q}var d=function(q,T,w){let R=_(T);if(w[1]==0)return[q+w[0],T];else return[q+w[0]-R,T+w[1]]},_=function(q){return q&1},a=[[1,0],[1,1],[0,1],[-1,0],[0,-1],[1,-1]];async function x(){const q=[64,64],T=1/Math.max(q[0],q[1]),R=await(await navigator.gpu?.requestAdapter())?.requestDevice();if(!R){fail("need a browser that supports WebGPU");return}else console.log("WebGPU is supported");const C=document.querySelector("canvas"),E=C.getContext("webgpu"),J=navigator.gpu.getPreferredCanvasFormat();E.configure({device:R,format:J});const W=await fetch("./shaders/hexgrid3d_vertex.wgsl").then((K)=>K.text()),M=await fetch("./shaders/hexgrid3d_fragment.wgsl").then((K)=>K.text()),N=R.createShaderModule({label:"HexGrid3D vertex shader",code:W}),X=R.createShaderModule({label:"HexGrid3D fragment shader",code:M}),p=8,Y=16,Z=16,$=8,H=q[0]*q[1]*p,O=Z,F=q[0]*q[1]*$,Q=R.createBuffer({label:"Hex attributes storage buffer for objects",size:H,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),k=R.createBuffer({label:"global attributes uniform",size:O,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),P=0,I=2;{const K=new Float32Array(H/4);for(let L=0;L<q[0]*q[1];++L){const g=L*(p/4);let U=L%q[0],B=Math.floor(L/q[0]);B%2==1||(U+=0.5),K.set([U*Math.sqrt(3)*T,B*3/2*T],g)}R.queue.writeBuffer(Q,0,K)}const j=R.createBuffer({label:"state buffer 0",size:F,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),A=new Int32Array(F/4),z=new Int32Array(F/4);for(let K=0;K<q[0]*q[1];++K){const L=K*($/4);if(K==q[0]*q[1]/2+q[0]/2)A.set([1,0],L),z.set(A)}const{vertexData:S,numVertices:f}=s({hexSize:T,center:{x:-1-T,y:-1+T}}),G=R.createBuffer({label:"storage buffer vertices",size:S.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});R.queue.writeBuffer(G,0,S);const l=R.createRenderPipeline({label:"HexGrid3D pipeline",layout:"auto",vertex:{module:N,entryPoint:"vs"},fragment:{module:X,entryPoint:"fs",targets:[{format:J}]}}),c=R.createBindGroup({label:"flip bind group for objects",layout:l.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:Q}},{binding:1,resource:{buffer:j}},{binding:2,resource:{buffer:k}},{binding:3,resource:{buffer:G}}]}),v={label:"our basic canvas renderPass",colorAttachments:[{clearValue:[0,0,0,1],loadOp:"clear",storeOp:"store"}]},y=new Float32Array(O/4);function D(K){var L=K;C.width=Math.max(1,R.limits.maxTextureDimension2D),C.height=Math.max(1,R.limits.maxTextureDimension2D);const g=L==1?A:z,U=L==1?z:A,B=m(g,U,q);v.colorAttachments[0].view=E.getCurrentTexture().createView();const b=R.createCommandEncoder({label:"our simulation renderer encoder"}),V=b.beginRenderPass(v);V.setPipeline(l);const u=C.width/C.height,h=1;y.set([h/u,h,q[0],q[1]],0),R.queue.writeBuffer(k,0,y),R.queue.writeBuffer(j,0,B),V.setBindGroup(0,c),V.draw(f,q[0]*q[1]),V.end();const o=b.finish();R.queue.submit([o]),L=1-L,setTimeout(()=>{D(L)},50)}D(1)}var s=function({hexSize:q=0.1,center:T={x:0,y:0}}={}){const R=new Float32Array(36),C=new Float32Array(12);for(let E=0;E<6;E++){const J=E*2,W=2*Math.PI*((E+0.5)/6);C[J]=q*Math.cos(W),C[J+1]=q*Math.sin(W)}for(let E=0;E<6;E++){const J=E*6,W=E*2;R[J+0]=T.x,R[J+1]=T.y,R[J+2]=T.x+C[W],R[J+3]=T.y+C[W+1],R[J+4]=T.x+C[(W+2)%12],R[J+5]=T.y+C[(W+3)%12]}return{vertexData:R,numVertices:18}};x();