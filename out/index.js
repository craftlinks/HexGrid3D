function d(R,q,J){for(var E=0;E<J[1];E=E+1)for(var H=0;H<J[0];H=H+1){let W=R[$(H,E)],L=I(H,E,R);if(L.fill(0),W>0)L[0]=1e4}for(var K=0;K<24;K+=1){for(var E=0;E<J[1];E=E+1)for(var H=0;H<J[0];H=H+1)v(H,E,1,K);for(var E=0;E<J[1];E=E+1)for(var H=0;H<J[0];H=H+1){var A=I(H,E,q);if(A[K]<80)A[K]=0;if(A[K+1]<80)A[K+1]=0}}for(var E=0;E<J[1];E=E+1)for(var H=0;H<J[0];H=H+1){var B=0,j=0;for(var K=0;K<11;K+=1)B+=I(H,E,q)[K];for(var K=12;K<24;K+=1)j+=I(H,E,q)[K];if(j=j+B,B>j*0.6)q[$(H,E)]=1;if(B<j*0.6)q[$(H,E)]=0;if(B==j*0.6){if(R[$(H,E)]==0)q[$(H,E)]=0;if(R[$(H,E)]==1)q[$(H,E)]=1}}function I(W,L,U){return U.subarray($(W,L)+1,$(W,L)+24+1)}function $(W,L){let U=(W+J[0])%J[0];return(L+J[1])%J[1]*(J[0]*25)+U*25}function v(W,L,U,M){var P=I(W,L,R);if(P[M]==0)return;let z=W,V=L;for(var F=0;F<U;F=F+1){let k=u(L);z=z-k,V=V-1}var X=[z,V];let S=P[M];for(var F=0;F<6;F=F+1)for(var g=0;g<U;g=g+1){if(P[M]<=0)break;P[M]-=Math.round(S*0.95/7);var w=I(X[0],X[1],q);w[M+1]+=Math.round(S*0.95/7),X=a(X[0],X[1],c[F])}P[M]-=S*0.05,w[M]+=S*0.05;while(P[M]>0){let k=Math.floor(Math.random()*7);if(P[M]-=1,k<=5)X=a(X[0],X[1],c[k]),w=I(X[0],X[1],q),w[M+1]+=1;else w[M]+=1}}return R}var a=function(R,q,J){let C=u(q);if(J[1]==0)return[R+J[0],q];else return[R+J[0]-C,q+J[1]]},u=function(R){return R&1},c=[[1,0],[1,1],[0,1],[-1,0],[0,-1],[1,-1]];async function s(){const R=[100,100],q=1/Math.max(R[0],R[1]),C=await(await navigator.gpu?.requestAdapter())?.requestDevice();if(!C){fail("need a browser that supports WebGPU");return}else console.log("WebGPU is supported");const N=document.querySelector("canvas"),Q=N.getContext("webgpu"),T=navigator.gpu.getPreferredCanvasFormat();Q.configure({device:C,format:T});const O=await fetch("./shaders/hexgrid3d_vertex.wgsl").then((Y)=>Y.text()),E=await fetch("./shaders/hexgrid3d_fragment.wgsl").then((Y)=>Y.text()),H=C.createShaderModule({label:"HexGrid3D vertex shader",code:O}),K=C.createShaderModule({label:"HexGrid3D fragment shader",code:E}),A=8,B=16,j=16,I=100,$=R[0]*R[1]*A,v=j,W=R[0]*R[1]*I,L=C.createBuffer({label:"Hex attributes storage buffer for objects",size:$,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),U=C.createBuffer({label:"global attributes uniform",size:v,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),M=0,P=2;{const Y=new Float32Array($/4);for(let Z=0;Z<R[0]*R[1];++Z){const y=Z*(A/4);let p=Z%R[0],G=Math.floor(Z/R[0]);G%2==1||(p+=0.5),Y.set([p*Math.sqrt(3)*q,G*3/2*q],y)}C.queue.writeBuffer(L,0,Y)}const z=C.createBuffer({label:"state buffer 0",size:W,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),V=new Int32Array(W/4),F=new Int32Array(W/4);for(let Y=0;Y<R[0]*R[1];++Y){const Z=Y*(I/4);if(Y==R[0]*R[1]/2+R[0]/2)V.set([1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],Z)}const{vertexData:X,numVertices:S}=_({hexSize:q,center:{x:-1-q,y:-1+q}}),g=C.createBuffer({label:"storage buffer vertices",size:X.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});C.queue.writeBuffer(g,0,X);const w=C.createRenderPipeline({label:"HexGrid3D pipeline",layout:"auto",vertex:{module:H,entryPoint:"vs"},fragment:{module:K,entryPoint:"fs",targets:[{format:T}]}}),k=C.createBindGroup({label:"flip bind group for objects",layout:w.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:L}},{binding:1,resource:{buffer:z}},{binding:2,resource:{buffer:U}},{binding:3,resource:{buffer:g}}]}),D={label:"our basic canvas renderPass",colorAttachments:[{clearValue:[0,0,0,1],loadOp:"clear",storeOp:"store"}]},h=new Float32Array(v/4);function m(Y){var Z=Y;N.width=Math.max(1,C.limits.maxTextureDimension2D),N.height=Math.max(1,C.limits.maxTextureDimension2D);const y=Z==1?V:F,p=Z==1?F:V,G=d(y,p,R);D.colorAttachments[0].view=Q.getCurrentTexture().createView();const f=C.createCommandEncoder({label:"our simulation renderer encoder"}),l=f.beginRenderPass(D);l.setPipeline(w);const o=N.width/N.height,b=1;h.set([b/o,b,R[0],R[1]],0),C.queue.writeBuffer(U,0,h),C.queue.writeBuffer(z,0,G),l.setBindGroup(0,k),l.draw(S,R[0]*R[1]),l.end();const x=f.finish();C.queue.submit([x]),Z=1-Z,setTimeout(()=>{m(Z)},1000)}m(1)}var _=function({hexSize:R=0.1,center:q={x:0,y:0}}={}){const C=new Float32Array(36),N=new Float32Array(12);for(let Q=0;Q<6;Q++){const T=Q*2,O=2*Math.PI*((Q+0.5)/6);N[T]=R*Math.cos(O),N[T+1]=R*Math.sin(O)}for(let Q=0;Q<6;Q++){const T=Q*6,O=Q*2;C[T+0]=q.x,C[T+1]=q.y,C[T+2]=q.x+N[O],C[T+3]=q.y+N[O+1],C[T+4]=q.x+N[(O+2)%12],C[T+5]=q.y+N[(O+3)%12]}return{vertexData:C,numVertices:18}};s();