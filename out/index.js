async function f(){const j=await(await navigator.gpu?.requestAdapter())?.requestDevice();if(!j){fail("need a browser that supports WebGPU");return}else console.log("WebGPU is supported");const R=document.querySelector("canvas"),E=R.getContext("webgpu"),H=navigator.gpu.getPreferredCanvasFormat();E.configure({device:j,format:H});const q=[10,10],C=1/Math.max(q[0],q[1]),J=4,y=8,I=await fetch("./shaders/hexgrid3d_vertex.wgsl").then((k)=>k.text()),V=await fetch("./shaders/hexgrid3d_fragment.wgsl").then((k)=>k.text()),_=await fetch("./shaders/hexgrid3d_compute.wgsl").then((k)=>k.text()),B=j.createShaderModule({label:"HexGrid3D vertex shader",code:I}),A=j.createShaderModule({label:"HexGrid3D fragment shader",code:V}),G=j.createShaderModule({label:"doubling compute module",code:_}),Y=j.createRenderPipeline({label:"HexGrid3D pipeline",layout:"auto",vertex:{module:B,entryPoint:"vs"},fragment:{module:A,entryPoint:"fs",targets:[{format:H}]}}),u=j.createComputePipeline({label:"compute pipeline",layout:"auto",compute:{module:G,entryPoint:"main",constants:{blockSize:y}}}),Z=8,z=16,g=16,$=q[0]*q[1]*Z,b=q[0]*q[1]*z,w=g,L=j.createBuffer({label:"Hex attributes storage buffer for objects",size:$,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),l=j.createBuffer({label:"colors storage buffer for objects",size:b,usage:GPUBufferUsage.STORAGE}),O=j.createBuffer({label:"global attributes uniform",size:w,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),h=0,m=2;{const k=new Float32Array($/4);for(let M=0;M<q[0]*q[1];++M){const N=M*(Z/4);let K=M%q[0],Q=Math.floor(M/q[0]);Q%2==1||(K+=0.5),k.set([K*Math.sqrt(3)*C,Q*3/2*C],N)}j.queue.writeBuffer(L,0,k)}const W=new Float32Array(w/4),{vertexData:F,numVertices:p}=S({hexSize:C,center:{x:-1-C,y:-1+C}}),P=j.createBuffer({label:"storage buffer vertices",size:F.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});j.queue.writeBuffer(P,0,F);const D=j.createBindGroup({label:"bind group for objects",layout:Y.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:L}},{binding:1,resource:{buffer:l}},{binding:2,resource:{buffer:O}},{binding:3,resource:{buffer:P}}]}),U={label:"our basic canvas renderPass",colorAttachments:[{clearValue:[0,0,0,1],loadOp:"clear",storeOp:"store"}]};function X(){U.colorAttachments[0].view=E.getCurrentTexture().createView();const k=j.createCommandEncoder({label:"our first triangle encoder"}),M=k.beginRenderPass(U);M.setPipeline(Y);const N=R.width/R.height,K=1;W.set([K/N,K,q[0],q[1]],0),j.queue.writeBuffer(O,0,W),M.setBindGroup(0,D),M.draw(p,q[0]*q[1]),M.end();const Q=k.finish();j.queue.submit([Q]),requestAnimationFrame(X)}X(),new ResizeObserver((k)=>{for(let M of k){const N=M.target,K=M.contentBoxSize[0].inlineSize,Q=M.contentBoxSize[0].blockSize;N.width=Math.max(1,Math.min(K,j.limits.maxTextureDimension2D)),N.height=Math.max(1,Math.min(Q,j.limits.maxTextureDimension2D)),X()}}).observe(R)}var S=function({hexSize:T=0.1,center:j={x:0,y:0}}={}){const E=new Float32Array(36),H=new Float32Array(12);for(let q=0;q<6;q++){const C=q*2,J=2*Math.PI*((q+0.5)/6);H[C]=T*Math.cos(J),H[C+1]=T*Math.sin(J)}for(let q=0;q<6;q++){const C=q*6,J=q*2;E[C+0]=j.x,E[C+1]=j.y,E[C+2]=j.x+H[J],E[C+3]=j.y+H[J+1],E[C+4]=j.x+H[(J+2)%12],E[C+5]=j.y+H[(J+3)%12]}return console.log(E),{vertexData:E,numVertices:18}};f();