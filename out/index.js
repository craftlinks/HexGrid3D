async function c(){const E=[512,512],k=1/Math.max(E[0],E[1]),w=await(await navigator.gpu?.requestAdapter())?.requestDevice();if(!w){fail("need a browser that supports WebGPU");return}else console.log("WebGPU is supported");const T=document.querySelector("canvas"),q=T.getContext("webgpu"),F=navigator.gpu.getPreferredCanvasFormat();q.configure({device:w,format:F});const _=await fetch("./shaders/hexgrid3d_vertex.wgsl").then((R)=>R.text()),b=await fetch("./shaders/hexgrid3d_fragment.wgsl").then((R)=>R.text()),S=await fetch("./shaders/hexgrid3d_compute.wgsl").then((R)=>R.text()),B=w.createShaderModule({label:"HexGrid3D vertex shader",code:_}),D=w.createShaderModule({label:"HexGrid3D fragment shader",code:b}),h=w.createShaderModule({label:"HexGrid3D compute module",code:S}),H=8,O=16,v=16,U=E[0]*E[1]*H,W=E[0]*E[1]*O,I=v,X=w.createBuffer({label:"Hex attributes storage buffer for objects",size:U,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),Q=w.createBuffer({label:"flip colors storage buffer for objects",size:W,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),Y=w.createBuffer({label:"flop colors storage buffer for objects",size:W,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),N=w.createBuffer({label:"global attributes uniform",size:I,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),o=0,s=2;{const R=new Float32Array(U/4);for(let j=0;j<E[0]*E[1];++j){const J=j*(H/4);let K=j%E[0],M=Math.floor(j/E[0]);M%2==1||(K+=0.5),R.set([K*Math.sqrt(3)*k,M*3/2*k],J)}w.queue.writeBuffer(X,0,R)}{const R=new Float32Array(W/4);for(let j=0;j<E[0]*E[1];++j){const J=j*(O/4);if(R.set([0,0,0,1],J),j==E[0]*E[1]/2+E[0]/2)R.set([1,0,0,1],J)}w.queue.writeBuffer(Q,0,R)}const{vertexData:P,numVertices:p}=x({hexSize:k,center:{x:-1-k,y:-1+k}}),Z=w.createBuffer({label:"storage buffer vertices",size:P.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});w.queue.writeBuffer(Z,0,P);const $=w.createComputePipeline({label:"compute pipeline",layout:"auto",compute:{module:h,entryPoint:"main"}}),y=w.createRenderPipeline({label:"HexGrid3D pipeline",layout:"auto",vertex:{module:B,entryPoint:"vs"},fragment:{module:D,entryPoint:"fs",targets:[{format:F}]}}),l=w.createBindGroup({label:"flip bind group for objects",layout:y.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:X}},{binding:1,resource:{buffer:Q}},{binding:2,resource:{buffer:N}},{binding:3,resource:{buffer:Z}}]}),f=w.createBindGroup({label:"flop bind group for objects",layout:y.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:X}},{binding:1,resource:{buffer:Y}},{binding:2,resource:{buffer:N}},{binding:3,resource:{buffer:Z}}]}),u=w.createBindGroup({layout:$.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:N}},{binding:1,resource:{buffer:Q}},{binding:2,resource:{buffer:Y}}]}),m=w.createBindGroup({layout:$.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:N}},{binding:1,resource:{buffer:Y}},{binding:2,resource:{buffer:Q}}]}),V={label:"our basic canvas renderPass",colorAttachments:[{clearValue:[0,0,0,1],loadOp:"clear",storeOp:"store"}]},A=new Float32Array(I/4);function z(R){var j=R;T.width=Math.max(1,w.limits.maxTextureDimension2D),T.height=Math.max(1,w.limits.maxTextureDimension2D),console.log(`loop_start: ${R}`),V.colorAttachments[0].view=q.getCurrentTexture().createView();const J=w.createCommandEncoder({label:"our first triangle encoder"}),K=J.beginComputePass();K.setPipeline($),K.setBindGroup(0,R?u:m),K.dispatchWorkgroups(E[0]/4,E[1]/4),K.end();const M=J.beginRenderPass(V);M.setPipeline(y);const d=T.width/T.height,G=1;A.set([G/d,G,E[0],E[1]],0),w.queue.writeBuffer(N,0,A),M.setBindGroup(0,R?l:f),M.draw(p,E[0]*E[1]),M.end();const a=J.finish();w.queue.submit([a]),j=1-j,setTimeout(()=>{z(j)},5)}z(1)}var x=function({hexSize:E=0.1,center:k={x:0,y:0}}={}){const C=new Float32Array(36),L=new Float32Array(12);for(let w=0;w<6;w++){const T=w*2,q=2*Math.PI*((w+0.5)/6);L[T]=E*Math.cos(q),L[T+1]=E*Math.sin(q)}for(let w=0;w<6;w++){const T=w*6,q=w*2;C[T+0]=k.x,C[T+1]=k.y,C[T+2]=k.x+L[q],C[T+3]=k.y+L[q+1],C[T+4]=k.x+L[(q+2)%12],C[T+5]=k.y+L[(q+3)%12]}return console.log(C),{vertexData:C,numVertices:18}};c();