async function x(){const E=[512,512],q=1/Math.max(E[0],E[1]),w=await(await navigator.gpu?.requestAdapter())?.requestDevice();if(!w){fail("need a browser that supports WebGPU");return}else console.log("WebGPU is supported");const j=document.querySelector("canvas"),y=j.getContext("webgpu"),$=navigator.gpu.getPreferredCanvasFormat();y.configure({device:w,format:$});const _=await fetch("./shaders/hexgrid3d_vertex.wgsl").then((W)=>W.text()),D=await fetch("./shaders/hexgrid3d_fragment.wgsl").then((W)=>W.text()),b=await fetch("./shaders/hexgrid3d_compute.wgsl").then((W)=>W.text()),B=w.createShaderModule({label:"HexGrid3D vertex shader",code:_}),S=w.createShaderModule({label:"HexGrid3D fragment shader",code:D}),h=w.createShaderModule({label:"HexGrid3D compute module",code:b}),H=8,O=16,p=16,U=E[0]*E[1]*H,Q=E[0]*E[1]*O,I=p,R=w.createBuffer({label:"Hex attributes storage buffer for objects",size:U,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),N=w.createBuffer({label:"flip colors storage buffer for objects",size:Q,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),T=w.createBuffer({label:"flop colors storage buffer for objects",size:Q,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),M=w.createBuffer({label:"global attributes uniform",size:I,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),o=0,s=2;{const W=new Float32Array(U/4);for(let k=0;k<E[0]*E[1];++k){const F=k*(H/4);let J=k%E[0],L=Math.floor(k/E[0]);L%2==1||(J+=0.5),W.set([J*Math.sqrt(3)*q,L*3/2*q],F)}w.queue.writeBuffer(R,0,W)}{const W=new Float32Array(Q/4);for(let k=0;k<E[0]*E[1];++k){const F=k*(O/4);if(W.set([0,0,0,1],F),k==E[0]*E[1]/2+E[0]/2)W.set([1,0,0,1],F)}w.queue.writeBuffer(N,0,W)}const{vertexData:V,numVertices:v}=c({hexSize:q,center:{x:-1-q,y:-1+q}}),X=w.createBuffer({label:"storage buffer vertices",size:V.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});w.queue.writeBuffer(X,0,V);const Y=w.createComputePipeline({label:"compute pipeline",layout:"auto",compute:{module:h,entryPoint:"main"}}),Z=w.createRenderPipeline({label:"HexGrid3D pipeline",layout:"auto",vertex:{module:B,entryPoint:"vs"},fragment:{module:S,entryPoint:"fs",targets:[{format:$}]}}),l=w.createBindGroup({label:"flip bind group for objects",layout:Z.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:R}},{binding:1,resource:{buffer:N}},{binding:2,resource:{buffer:M}},{binding:3,resource:{buffer:X}}]}),f=w.createBindGroup({label:"flop bind group for objects",layout:Z.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:R}},{binding:1,resource:{buffer:T}},{binding:2,resource:{buffer:M}},{binding:3,resource:{buffer:X}}]}),m=w.createBindGroup({layout:Y.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:M}},{binding:1,resource:{buffer:N}},{binding:2,resource:{buffer:T}}]}),u=w.createBindGroup({layout:Y.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:M}},{binding:1,resource:{buffer:T}},{binding:2,resource:{buffer:N}}]}),P={label:"our basic canvas renderPass",colorAttachments:[{clearValue:[0,0,0,1],loadOp:"clear",storeOp:"store"}]},A=new Float32Array(I/4);function z(W){var k=W;j.width=Math.max(1,w.limits.maxTextureDimension2D),j.height=Math.max(1,w.limits.maxTextureDimension2D),console.log(`loop_start: ${W}`),P.colorAttachments[0].view=y.getCurrentTexture().createView();const F=w.createCommandEncoder({label:"our first triangle encoder"}),J=F.beginComputePass();J.setPipeline(Y),J.setBindGroup(0,W?m:u),J.dispatchWorkgroups(E[0],E[1]),J.end();const L=F.beginRenderPass(P);L.setPipeline(Z);const d=j.width/j.height,g=1;A.set([g/d,g,E[0],E[1]],0),w.queue.writeBuffer(M,0,A),L.setBindGroup(0,W?l:f),L.draw(v,E[0]*E[1]),L.end();const a=F.finish();w.queue.submit([a]),k=1-k,setTimeout(()=>{z(k)},10)}z(1)}var c=function({hexSize:E=0.1,center:q={x:0,y:0}}={}){const C=new Float32Array(36),K=new Float32Array(12);for(let w=0;w<6;w++){const j=w*2,y=2*Math.PI*((w+0.5)/6);K[j]=E*Math.cos(y),K[j+1]=E*Math.sin(y)}for(let w=0;w<6;w++){const j=w*6,y=w*2;C[j+0]=q.x,C[j+1]=q.y,C[j+2]=q.x+K[y],C[j+3]=q.y+K[y+1],C[j+4]=q.x+K[(y+2)%12],C[j+5]=q.y+K[(y+3)%12]}return console.log(C),{vertexData:C,numVertices:18}};x();