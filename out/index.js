async function c(){const q=[1024,1024],y=1/Math.max(q[0],q[1]),w=await(await navigator.gpu?.requestAdapter())?.requestDevice();if(!w){fail("need a browser that supports WebGPU");return}else console.log("WebGPU is supported");const k=document.querySelector("canvas"),E=k.getContext("webgpu"),F=navigator.gpu.getPreferredCanvasFormat();E.configure({device:w,format:F});const B=await fetch("./shaders/hexgrid3d_vertex.wgsl").then((j)=>j.text()),b=await fetch("./shaders/hexgrid3d_fragment.wgsl").then((j)=>j.text()),D=await fetch("./shaders/hexgrid3d_compute.wgsl").then((j)=>j.text()),S=w.createShaderModule({label:"HexGrid3D vertex shader",code:B}),h=w.createShaderModule({label:"HexGrid3D fragment shader",code:b}),p=w.createShaderModule({label:"HexGrid3D compute module",code:D}),O=8,U=16,v=16,I=q[0]*q[1]*O,R=q[0]*q[1]*U,P=v,T=w.createBuffer({label:"Hex attributes storage buffer for objects",size:I,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),Q=w.createBuffer({label:"flip colors storage buffer for objects",size:R,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),W=w.createBuffer({label:"flop colors storage buffer for objects",size:R,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),N=w.createBuffer({label:"global attributes uniform",size:P,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),s=0,n=2;{const j=new Float32Array(I/4);for(let C=0;C<q[0]*q[1];++C){const K=C*(O/4);let J=C%q[0],L=Math.floor(C/q[0]);L%2==1||(J+=0.5),j.set([J*Math.sqrt(3)*y,L*3/2*y],K)}w.queue.writeBuffer(T,0,j)}{const j=new Float32Array(R/4);for(let C=0;C<q[0]*q[1];++C){const K=C*(U/4);j.set([0,0,0,1],K);let J=Math.floor(C/q[0]),L=C%q[0];if($(1)>0.99999)j.set([1,$(1),$(0.75),1],K)}w.queue.writeBuffer(Q,0,j)}const{vertexData:V,numVertices:l}=o({hexSize:y,center:{x:-1-y,y:-1+y}}),X=w.createBuffer({label:"storage buffer vertices",size:V.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});w.queue.writeBuffer(X,0,V);const Y=w.createComputePipeline({label:"compute pipeline",layout:"auto",compute:{module:p,entryPoint:"main"}}),Z=w.createRenderPipeline({label:"HexGrid3D pipeline",layout:"auto",vertex:{module:S,entryPoint:"vs"},fragment:{module:h,entryPoint:"fs",targets:[{format:F}]}}),m=w.createBindGroup({label:"flip bind group for objects",layout:Z.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:T}},{binding:1,resource:{buffer:Q}},{binding:2,resource:{buffer:N}},{binding:3,resource:{buffer:X}}]}),f=w.createBindGroup({label:"flop bind group for objects",layout:Z.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:T}},{binding:1,resource:{buffer:W}},{binding:2,resource:{buffer:N}},{binding:3,resource:{buffer:X}}]}),u=w.createBindGroup({layout:Y.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:N}},{binding:1,resource:{buffer:Q}},{binding:2,resource:{buffer:W}}]}),x=w.createBindGroup({layout:Y.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:N}},{binding:1,resource:{buffer:W}},{binding:2,resource:{buffer:Q}}]}),A={label:"our basic canvas renderPass",colorAttachments:[{clearValue:[0,0,0,1],loadOp:"clear",storeOp:"store"}]},z=new Float32Array(P/4);function g(j){var C=j;k.width=Math.max(1,w.limits.maxTextureDimension2D),k.height=Math.max(1,w.limits.maxTextureDimension2D),A.colorAttachments[0].view=E.getCurrentTexture().createView();const K=w.createCommandEncoder({label:"our first triangle encoder"}),J=K.beginComputePass();J.setPipeline(Y),J.setBindGroup(0,j?u:x),J.dispatchWorkgroups(q[0]/4,q[1]/4),J.end();const L=K.beginRenderPass(A);L.setPipeline(Z);const d=k.width/k.height,G=1;z.set([G/d,G,q[0],q[1]],0),w.queue.writeBuffer(N,0,z),L.setBindGroup(0,j?m:f),L.draw(l,q[0]*q[1]),L.end();const a=K.finish();w.queue.submit([a]),C=1-C,setTimeout(()=>{g(C)},70)}g(1)}var o=function({hexSize:q=0.1,center:y={x:0,y:0}}={}){const H=new Float32Array(36),M=new Float32Array(12);for(let w=0;w<6;w++){const k=w*2,E=2*Math.PI*((w+0.5)/6);M[k]=q*Math.cos(E),M[k+1]=q*Math.sin(E)}for(let w=0;w<6;w++){const k=w*6,E=w*2;H[k+0]=y.x,H[k+1]=y.y,H[k+2]=y.x+M[E],H[k+3]=y.y+M[E+1],H[k+4]=y.x+M[(E+2)%12],H[k+5]=y.y+M[(E+3)%12]}return console.log(H),{vertexData:H,numVertices:18}};c();var $=(q,y)=>{if(q===void 0)q=0,y=1;else if(y===void 0)y=q,q=0;return q+Math.random()*(y-q)};
