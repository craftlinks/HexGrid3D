async function v(){const w=[64,64],E=1/Math.max(w[0],w[1]),q=await(await navigator.gpu?.requestAdapter())?.requestDevice();if(!q){fail("need a browser that supports WebGPU");return}else console.log("WebGPU is supported");const C=document.querySelector("canvas"),K=C.getContext("webgpu"),X=navigator.gpu.getPreferredCanvasFormat();K.configure({device:q,format:X});const z=await fetch("./shaders/hexgrid3d_vertex.wgsl").then((k)=>k.text()),B=await fetch("./shaders/hexgrid3d_fragment.wgsl").then((k)=>k.text()),G=await fetch("./shaders/hexgrid3d_compute.wgsl").then((k)=>k.text()),g=q.createShaderModule({label:"HexGrid3D vertex shader",code:z}),b=q.createShaderModule({label:"HexGrid3D fragment shader",code:B}),p=q.createShaderModule({label:"HexGrid3D compute module",code:G}),Y=8,Z=16,S=16,$=w[0]*w[1]*Y,F=w[0]*w[1]*Z,H=S,O=q.createBuffer({label:"Hex attributes storage buffer for objects",size:$,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),R=q.createBuffer({label:"colors storage buffer for objects",size:F,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),T=q.createBuffer({label:"global attributes uniform",size:H,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),u=0,d=2;{const k=new Float32Array($/4);for(let j=0;j<w[0]*w[1];++j){const J=j*(Y/4);let N=j%w[0],Q=Math.floor(j/w[0]);Q%2==1||(N+=0.5),k.set([N*Math.sqrt(3)*E,Q*3/2*E],J)}q.queue.writeBuffer(O,0,k)}{const k=new Float32Array(F/4);for(let j=0;j<w[0]*w[1];++j){const J=j*(Z/4);if(k.set([0,0,0,1],J),j==55)k.set([1,0,0,1],J)}q.queue.writeBuffer(R,0,k)}const{vertexData:U,numVertices:l}=m({hexSize:E,center:{x:-1-E,y:-1+E}}),y=q.createBuffer({label:"storage buffer vertices",size:U.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});q.queue.writeBuffer(y,0,U);const I=q.createComputePipeline({label:"compute pipeline",layout:"auto",compute:{module:p,entryPoint:"main"}}),P=q.createRenderPipeline({label:"HexGrid3D pipeline",layout:"auto",vertex:{module:g,entryPoint:"vs"},fragment:{module:b,entryPoint:"fs",targets:[{format:X}]}}),D=q.createBindGroup({label:"bind group for objects",layout:P.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:O}},{binding:1,resource:{buffer:R}},{binding:2,resource:{buffer:T}},{binding:3,resource:{buffer:y}}]}),h=q.createBindGroup({layout:I.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:T}},{binding:1,resource:{buffer:R}}]}),V={label:"our basic canvas renderPass",colorAttachments:[{clearValue:[0,0,0,1],loadOp:"clear",storeOp:"store"}]},_=new Float32Array(H/4);function W(){V.colorAttachments[0].view=K.getCurrentTexture().createView();const k=q.createCommandEncoder({label:"our first triangle encoder"}),j=k.beginComputePass();j.setPipeline(I),j.setBindGroup(0,h),j.dispatchWorkgroups(w[0],w[1]),j.end();const J=k.beginRenderPass(V);J.setPipeline(P);const N=C.width/C.height,Q=1;_.set([Q/N,Q,w[0],w[1]],0),q.queue.writeBuffer(T,0,_),J.setBindGroup(0,D),J.draw(l,w[0]*w[1]),J.end();const f=k.finish();q.queue.submit([f]),setTimeout(W,10)}W(0),new ResizeObserver((k)=>{for(let j of k){const J=j.target,N=j.contentBoxSize[0].inlineSize,Q=j.contentBoxSize[0].blockSize;J.width=Math.max(1,Math.min(N,q.limits.maxTextureDimension2D)),J.height=Math.max(1,Math.min(Q,q.limits.maxTextureDimension2D)),W()}}).observe(C)}var m=function({hexSize:w=0.1,center:E={x:0,y:0}}={}){const L=new Float32Array(36),M=new Float32Array(12);for(let q=0;q<6;q++){const C=q*2,K=2*Math.PI*((q+0.5)/6);M[C]=w*Math.cos(K),M[C+1]=w*Math.sin(K)}for(let q=0;q<6;q++){const C=q*6,K=q*2;L[C+0]=E.x,L[C+1]=E.y,L[C+2]=E.x+M[K],L[C+3]=E.y+M[K+1],L[C+4]=E.x+M[(K+2)%12],L[C+5]=E.y+M[(K+3)%12]}return console.log(L),{vertexData:L,numVertices:18}};v();